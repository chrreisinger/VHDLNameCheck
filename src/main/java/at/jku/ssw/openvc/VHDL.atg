import at.jku.ssw.openvc.ast.*;
import at.jku.ssw.openvc.ast.concurrentStatements.*;
import at.jku.ssw.openvc.ast.declarations.*;
import at.jku.ssw.openvc.ast.expressions.*;
import at.jku.ssw.openvc.ast.sequentialStatements.*;
import scala.Either;
import scala.Left;
import scala.Right;
import scala.Tuple2;
import scala.Option;
import scala.collection.Seq;

COMPILER VHDL
  	private static class ListBuffer<T> {
		private scala.collection.mutable.ListBuffer<T> impl=new scala.collection.mutable.ListBuffer<T>();
		public void append(T x){
			if (x!=null) impl.$plus$eq(x);
		}
		public void appendAll(Seq<T> x){
			if (x!=null) impl.appendAll(x);
		}
		public void prepend(T x){
			if (x!=null) impl.$plus$eq$colon(x);
		}
		public Seq<T> toList(){
			return impl.toList();
		}
		public boolean isEmpty(){
			return impl.isEmpty();
		}
	}
	
	private static <T> Option<T> toOption(T x){return Option.apply(x);}
	
	//group_template = group Identifier is lparen ...
	//GroupDeclaration = group Identifier colon ...
	//la == group
	private boolean isGroupTemplate() {
		if (la.kind!=_group) return false;
		scanner.ResetPeek();
		scanner.Peek();
		Token next = scanner.Peek();
		return next.kind==_is;
	}

	//AttributeDeclaration = attribute Identifier colon TypeMark semicolon 
	//AttributeSpecification = attribute Identifier of EntityNameList colon EntityClass is Expression semicolon 
	//la == attribute
	private boolean isAttributeDeclaration() {
		if (la.kind!=_attribute) return false;
		scanner.ResetPeek();
		scanner.Peek();
		Token next=scanner.Peek();
		return next.kind==_colon;
	}

	//PhysicalTypeDefinition = range Range units ...
	//IntegerOrFloatingPointTypeDefinition = range Range semicolon
	//la == range
	private boolean isPhysicalType() {
		if (la.kind!=_range) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_units && next.kind!=_semicolon);
		return next.kind==_units;
	}

	//constrained array = lparen IndexSubtypeDefinition {comma IndexSubtypeDefinition} rparen of SubtypeIndication
	//IndexSubtypeDefinition = TypeMark range box
	//IndexConstraint = lparen DiscreteRange (comma  DiscreteRange)* rparen
	//la==lparen
	private boolean isIndexSubtypeDefinition() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_box && next.kind!=_semicolon && next.kind!=_rparen && next.kind!=_lparen);
		return next.kind==_box;
	}
	
	//ProcedureCallStatement = SelectedName [lparen AssociationList rparen] semicolon
	//SignalOrVariableAssignmentStatement = Target (varAssign|leq) ....
	//Target = Name | Aggregate
	private boolean isAssignmentStatement() {
		scanner.ResetPeek();
		Token next;
		int count=0;
		do {
			next = scanner.Peek();
			if (next.kind==_lparen) count++;
			else if (next.kind==_rparen) count--;
		}while (next.kind!=_varAssign && next.kind!=_leq && next.kind!=_semicolon);
		return (next.kind==_varAssign || next.kind==_leq) && count==0;
	}
	
	//ConcurrentSignalAssignmentStatement = (Target leq | with) ....
	//ConcurrentProcedureCallStatement = SelectedName [lparen AssociationList rparen] semicolon
	private boolean isConcurrentSignalAssignmentStatement() {
		if (la.kind==_with) return true;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_leq && next.kind!=_semicolon);
		return next.kind==_leq;
	}
	
	//
	//For those parameters with modes, the only modes that are allowed for formal parameters of a procedure are
	//in, inout, and out. If the mode is in and no object class is explicitly specified, constant is assumed. If the
	//mode is inout or out, and no object class is explicitly specified, variable is assumed.
	//
	//InterfaceConstantDeclaration = [constant] IdentifierList colon [in] SubtypeIndication [varAssign Expression] 
	private boolean isInterfaceConstantDeclaration() {
		if (la.kind==_constant) return true;
		else if (la.kind==_variable || la.kind==_signal || la.kind==_file) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_varAssign && next.kind!=_semicolon && next.kind!=_in);
		return next.kind==_in;
	}
	
	//InterfaceVariableDeclaration = [variable] IdentifierList colon [InterfaceMode] SubtypeIndication [varAssign Expression]
	private boolean isInterfaceVariableDeclaration() {
		if (la.kind==_variable) return true;
		else if (la.kind==_constant || la.kind==_signal || la.kind==_file) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_varAssign && next.kind!=_semicolon && next.kind!=_in && next.kind!=_inout && next.kind!=_outToken);
		return next.kind==_inout || next.kind==_outToken;
	}

	//search fo TO or downto in Range: Expression Direction Expression
	//Choice = DiscreteRange
	//	| SimpleExpression
	//	| others		
	//Choices = Choice { bar Choice}
	//CaseStatement = .... {when Choices arrow SequentialStatementList} ...
	//ElementAssociation = [Choices arrow] Expression 
	//SelectedWaveform = Waveform when Choices
	//SelectedSignalAssignment = ... SelectedWaveform {comma SelectedWaveform} semicolon
	private boolean isRangeInChoice() {
		if (la.kind==_others) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_bar && next.kind!=_arrow && next.kind!=_comma && next.kind!=_semicolon && next.kind!=_to && next.kind!=_downto);
		return next.kind==_to || next.kind==_downto;
	}
	
	//search fo TO or downto in Range = Expression Direction Expression
	//BlockConfigurationIndex= 
	//	  DiscreteRange
	//	  |Expression
	//BlockSpecification=
	//	Identifier [lparen BlockConfigurationIndex rparen]
	//	 | SelectedName
	//BlockConfiguration =
	//		for BlockSpecification
	//		{UseClause}
	//		{
	//			blockConfiguration
	//			|ComponentConfiguration
	//		}
	//		END for semicolon 
	private boolean isDiscreteRangeInBlockConfigurationIndex() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_use && next.kind!=_for && next.kind!=_end && next.kind!=_semicolon && next.kind!=_to && next.kind!=_downto);
		return next.kind==_to || next.kind==_downto;
	}
	
		/*
		ArchitectureStatement =
		(
		LabelColon<out label> (
			ArchitectureStatementWithLabel<out concurrentStmt,label>
			| ArchitectureStatementOptionalLabel<out concurrentStmt,label>
			)
		| ArchitectureStatementOptionalLabel<out concurrentStmt,label>
		)
		.

		ArchitectureStatementWithLabel =
				(
				ComponentInstantiationStatement
				| BlockStatement //starts with block
				| GenerateStatement  //starts with for|IF
				)
				.

		ArchitectureStatementOptionalLabel<out ConcurrentStatement concurrentStmt, Identifier label> =
				[postponed]
				(ProcessStatement //starts with process
				| ConcurrentAssertionStatement //starts with assert
				| IF(isConcurrentSignalAssignmentStatement()) ConcurrentSignalAssignmentStatement
				| ConcurrentProcedureCallStatement
				)

		ComponentInstantiationStatement =
		(
		  [component] SelectedName
		  | entity SelectedName [lparen Identifier rparen]
		  | configuration SelectedName
		)
		[GenericMapAspect]
		[PortMapAspect] semicolon
	*/
	private boolean isArchitectureStatementWithLabel() {
		if (la.kind==_component || la.kind==_entity || la.kind==_configuration  || la.kind==_block || la.kind==_for || la.kind==_if) return true;
		else if (la.kind==_postponed || la.kind==_process || la.kind==_assert || la.kind==_file || isConcurrentSignalAssignmentStatement()) return false;
		//distinguish between ComponentInstantiationStatement and ConcurrentProcedureCallStatement
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_generic && next.kind!=_port && next.kind!=_semicolon);
		return next.kind==_generic || next.kind==_port;
	}

	//NameSlicePart = lparen DiscreteRange rparen.
	//name_indexed_part = lparen Expression {comma Expression}
	//NameAssociationListPart = lparen AssociationList rparen
	private boolean isNameSlicePart() {
		if (la.kind!=_lparen) return false;
		scanner.ResetPeek();
		Token next;
		int count=1;//count lparen
		do {
			next = scanner.Peek();
			if (next.kind==_lparen) count++;
			else if (next.kind==_rparen) count--;
		}while (count!=0 && next.kind!=_bar && next.kind!=_arrow && next.kind!=_semicolon && next.kind!=_to && next.kind!=_downto);
		return (next.kind==_to || next.kind==_downto) && count<=1;
	}

	/*
	Choice =
			IF(isRangeInChoice()) DiscreteRange
			| SimpleExpression
			| others
	Choices = Choice {bar Choice}.
	ElementAssociation = [IF(isChoiceInElementAssociation()) Choices arrow] Expression.
	Aggregate = lparen  ElementAssociation {comma ElementAssociation} rparen .
	*/
	private boolean isChoiceInElementAssociation() {
		scanner.ResetPeek();
		Token next=la;
		int count=1;//count lparen
		do {
			if (next.kind==_lparen) count++;
			else if (next.kind==_rparen) count--;
			next = scanner.Peek();
		}while (count!=0 && next.kind!=_comma && next.kind!=_arrow && next.kind!=_semicolon && next.kind!=_others);
		return (next.kind==_arrow || next.kind==_others) && count<=1;
	}

	/*
	FormalPart<out Name FormalPart> = Name<out FormalPart> .
	ActualPart<out Option<Expression> ActualPart> =  Expression | open .
	AssociationElement = [If(isFormalPartInAssociationElement()) FormalPart arrow] ActualPart .
	AssociationList<out AssociationList list> = AssociationElement {comma AssociationElement}.
	lparen AssociationList rparen
	*/
	private boolean isFormalPartInAssociationElement() {
		if (la.kind!=_basicIdentifier && la.kind!=_extendedIdentifier) return false;
		scanner.ResetPeek();
		Token next;
		int count=0;
		do {
			next = scanner.Peek();
			if (next.kind==_lparen) count++;
			else if (next.kind==_rparen) count--;
		}while (count>=0 && next.kind!=_comma && next.kind!=_others && next.kind!=_arrow && next.kind!=_semicolon && next.kind!=_open);
		return next.kind==_arrow && count==0;
	}

	//Range = SimpleExpression Direction  SimpleExpression
	//		| Name
	private boolean isNotNameInRange() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_units && next.kind!=_varAssign && next.kind!=_generate && next.kind!=_loop && next.kind!=_is && next.kind!=_open && next.kind!=_semicolon && next.kind!=_to && next.kind!=_downto);
		return next.kind==_to || next.kind==_downto;
	}

	//DiscreteRange = SubtypeIndication
	//				|Range.
	private boolean isSubtypeIndicationInDiscreteRange() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_range && next.kind!=_apostrophe && next.kind!=_to && next.kind!=_downto && next.kind!=_lparen && next.kind!=_semicolon);
		return next.kind==_range;
	}

	private boolean isQualifiedExpression() {
		if (la.kind!=_basicIdentifier && la.kind!=_extendedIdentifier) return false;
		scanner.ResetPeek();
		Token next;
		//match SelectedName
		do {
			next = scanner.Peek();
		}while (next.kind==_basicIdentifier || next.kind==_extendedIdentifier ||  next.kind==_dot);
		return next.kind==_apostrophe && scanner.Peek().kind==_lparen;
	}

	private boolean isComponentConfigurationInBlockConfiguration() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_colon && next.kind!=_lparen &&  next.kind!=_for);
		return next.kind==_colon;
	}

	private Position toPosition(Token token){
		return new Position(token.line,token.col);
	}

	private Identifier toIdentifier(Token token){
		return toIdentifier(token,true);
	}

	private Identifier toIdentifier(Token token,boolean toLowerCase){
    	if (token.kind!=_stringLiteral && token.kind!=_characterLiteral){
    		return new Identifier(toPosition(token),toLowerCase?token.val.toLowerCase():token.val.replace("\\\\","\\"));
    	}else{
    		return new Identifier(toPosition(token),token.val);
    	}
	}

IGNORECASE
CHARACTERS
  	eol 			= '\r' + '\n' .//+ '\u000C'.

  	digit = '0'..'9' .

  	//A B C D E F G H I J K L M N O P Q R S T U V W X Y Z � � � � � � � � � � � � � � � � D . � � � � � � � � � � � � Y P '
  	upperCaseLetter = 'A'..'Z' + '\u00c0'..'\u00d6' + '\u00d8' .. '\u00de'. //A - Z,� - �, � - �

  	//a b c d e f g h i j k l m n o p q r s t u v w x y z � � � � � � � � � � � � � � � � �  � � � � � � � � � � � � y ' p �
  	lowerCaseLetter = 'a'..'z' + '\u00df'..'\u00f6' + '\u00f8'.. '\u00ff'. //a-z,� - �, � - �

  	specialCharacter = '#' + '&' + '\'' + '(' + ')' + '*' + '+' + ',' + '-'
  		+ '.' + '/' + ':' + ';' + '<' + '=' + '>' + '[' + ']' + '_' + '|'.

  	spcaeCharacter = ' ' + '\u00a0'. //space, non-breaking space

  	otherSpecialCharacter =  '!' + '$' + '%' + '@' + '?' + '^' + '`' + '{' + '}' + '~'
		+ '\u00a1'..'\u00bf' + '\u00d7' + '\u00f7'.//  � - �, � - �

  	letter = upperCaseLetter + lowerCaseLetter.

  	graphicCharacter =
  		upperCaseLetter
  		+ digit
  		+ specialCharacter
  		+ spcaeCharacter
  		+ lowerCaseLetter
  		+ otherSpecialCharacter
  		.

  	notApostrophe = ANY - "'".

  	newline =  '\r' +'\n'.

  	letterOrDigit =  letter + digit.

  	extendedDigit = digit + letter.

  	baseSpecifier = 'b' + 'o' + 'x'.

TOKENS

	basicIdentifier = letter { letterOrDigit | '_' }.

	//extended identifiers can't contain a single backslash
	extendedIdentifier = "\\" { "\"" | "\\\\" | graphicCharacter } "\\".

	basedLiteral = digit { ['_'] digit } '#' extendedDigit { ['_'] extendedDigit } [ '.' extendedDigit { ['_'] extendedDigit } ] '#' ['e' [ '+' | '-' ] digit { ['_'] digit }].

	integerLiteral = digit { ['_'] digit } ['e' [ '+' | '-' ] digit { ['_'] digit }].

	realLiteral = digit { ['_'] digit }  '.' digit { ['_'] digit }  ['e' [ '+' | '-' ] digit { ['_'] digit }] .

	//string literals can't contain a single quotation mark
	stringLiteral = "\"" { "\"\"" | "\\" | graphicCharacter } "\"".

	bitStringLiteral = baseSpecifier '\"' [extendedDigit { ['_'] extendedDigit }] '\"'.

	apostrophe = "'" CONTEXT ((letter|"(") notApostrophe).

	characterLiteral = "'" ("\"" | "\\" | graphicCharacter ) "'".

  	abs="abs".
	access="access".
	after="after".
	alias="alias".
	all="all".
	and="and".
	architecture="architecture".
	array="array".
	assert="assert".
	attribute="attribute".
	begin="begin".
	block="block".
	body="body".
	buffer="buffer".
	bus="bus".
	case="case".
	component="component".
	configuration="configuration".
	constant="constant".
	disconnect="disconnect".
	downto="downto".
	else="else".
	ELSIF="elsif".
	end="end".
	entity="entity".
	exit="exit".
	file="file".
	for="for".
	function="function".
	generate="generate".
	generic="generic".
	group="group".
	guarded="guarded".
	if="if".
	impure="impure".
	in="in".
	inertial="inertial".
	inout="inout".
	is="is".
	label="label".
	library="library".
	linkage="linkage".
	literal="literal".
	loop="loop".
	map="map".
	mod="mod".
	nand="nand".
	new="new".
	next="next".
	nor="nor".
	not="not".
	null="null".
	of="of".
	on="on".
	open="open".
	or="or".
	others="others".
	outToken="out".
	package="package".
	port="port".
	postponed="postponed".
	procedure="procedure".
	process="process".
	protected="protected".
	pure="pure".
	range="range".
	record="record".
	register="register".
	reject="reject".
	rem="rem".
	report="report".
	return="return".
	rol="rol".
	ror="ror".
	select="select".
	severity="severity".
	shared="shared".
	signal="signal".
	sla="sla".
	sll="sll".
	sra="sra".
	srl="srl".
	subtype="subtype".
	then="then".
	to="to".
	transport="transport".
	type="type".
	unaffected="unaffected".
	units="units".
	until="until".
	use="use".
	variable="variable".
	wait="wait".
	when="when".
	while="while".
	with="with".
	xnor="xnor".
	xor="xor".

  	doublestar    = "**".
  	leq           = "<=".
  	geq           = ">=".
  	arrow         = "=>".
  	neq           = "/=".
  	varAssign    = ":=".
  	box           = "<>".
  	semicolon     = ";".
  	comma         = ",".
  	ampersand     = "&".
  	lparen        = "(".
  	rparen        = ")".
  	lbracket      = "[".
  	rbracket      = "]".
  	colon         = ":".
  	mul           = "*".
  	div           = "/".
  	plus          = "+".
  	minus         = "-".
  	lt            = "<".
 	gt            = ">".
  	eq            = "=".
  	bar           = "|".
  	dot           = ".".

COMMENTS FROM "/*" TO "*/" NESTED
//A comment can appear on any line of a VHDL description and may contain any character except the format effectors vertical tab, carriage return, line feed, and form feed.
COMMENTS FROM "--" TO '\u000a' //line feed
IGNORE '\t' + ' ' + newline

PRODUCTIONS

VHDL<out DesignFile designFile> =
    (.
        ListBuffer<DesignUnit> units=new ListBuffer<DesignUnit>();
        la = new Token();
        la.val = "";
        Get();
    .)
    DesignUnit<out DesignUnit designUnit> (. units.append(designUnit); .) { DesignUnit<out designUnit> (. units.append(designUnit); .) }
    (.
        designFile=new DesignFile(units.toList());
        Expect(0);
    .)
    .

DesignUnit<out DesignUnit designUnit> =
    (.
        ListBuffer<Identifier> libraries=new ListBuffer<Identifier>();
        ListBuffer<UseClause> useClauses=new ListBuffer<UseClause>();
    .)
    {
    LibraryClause<.out Seq<Identifier> identifierList.> (.libraries.appendAll(identifierList);.)
    | UseClause<out UseClause useClause> (.useClauses.append(useClause);.)
    } (.Position pos=toPosition(la);.) LibraryUnit<out LibraryUnit libraryUnit>
    (.designUnit=new DesignUnit(pos,libraries.toList(),useClauses.toList(),toOption(libraryUnit));.)
    .

LibraryUnit<out LibraryUnit libraryUnit> =
    (.libraryUnit=null;.)
    (
    EntityDeclaration<out libraryUnit>
    | ArchitectureBody<out libraryUnit>
    | IF(la.kind==_package && scanner.Peek().kind==_body) PackageBody<out libraryUnit>
    | PackageDeclaration<out libraryUnit>
    | ConfigurationDeclaration<out libraryUnit>
    )
    .

LibraryClause<out Seq<Identifier> identifierList> =
	library IdentifierList<out identifierList> semicolon
	.

GenericClause<out InterfaceList genericList> =
    generic lparen GenericInterfaceList<out genericList> rparen semicolon
    .

GenericInterfaceList<out InterfaceList list> =
    (. ListBuffer<InterfaceList.AbstractInterfaceElement> elements=new ListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    InterfaceConstantDeclaration<out InterfaceList.InterfaceConstantDeclaration declaration> (.elements.append(declaration);.) { semicolon InterfaceConstantDeclaration<out declaration> (.elements.append(declaration); .)}
    (. list=new InterfaceList(elements.toList());.)
    .

PortClause<out InterfaceList portList> =
    port lparen PortInterfaceList<out portList> rparen semicolon
    .

PortInterfaceList<out InterfaceList list> =
	(. ListBuffer<InterfaceList.AbstractInterfaceElement> elements=new ListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    InterfaceSignalDeclarationProcedure<out InterfaceList.InterfaceSignalDeclaration declaration> (.elements.append(declaration); .) { semicolon InterfaceSignalDeclarationProcedure<out declaration> (.elements.append(declaration);.)}
    (.list=new InterfaceList(elements.toList());.)
    .

EntityDeclaration<out EntityDeclaration entityDecl> =
    (.
        ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();
        ListBuffer<ConcurrentStatement> concurrentStatements=new ListBuffer<ConcurrentStatement>();
        InterfaceList genericClause=null,portClause=null;
        ConcurrentStatement stmt=null;
        Identifier label=null;
        boolean postponed=false;
    .)
    entity Identifier<out Identifier identifier> is
        [GenericClause<out genericClause>]
        [PortClause<out portClause>]
        {EntityDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item); .)}
    [begin
        {[IF(scanner.Peek().kind==_colon) LabelColon<out label>] [postponed (.postponed=true;.)]
        (
        ConcurrentAssertionStatement<out stmt,label,postponed>
        | ConcurrentProcedureCallStatement<out stmt,label,postponed>
        | ProcessStatement<out stmt,label,postponed>
        )
        (.concurrentStatements.append(stmt);.)
        }]
    end [entity] [UnusedIdentifier] semicolon
    (.entityDecl=new EntityDeclaration(identifier,toOption(genericClause),toOption(portClause),declarativeItems.toList(),concurrentStatements.toList());.)
    .

EntityDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | SignalDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | DisconnectionSpecification<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
	.

ArchitectureBody<out ArchitectureDeclaration archDecl> =
    (.ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();.)
    architecture Identifier<out Identifier identifier> of SelectedName<out SelectedName entityName> is
        {BlockDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item); .)}
    begin
        ArchitectureStatementList<.out Seq<ConcurrentStatement> statementList.>
    end [architecture] [UnusedIdentifier] semicolon
    (.archDecl=new ArchitectureDeclaration(identifier,declarativeItems.toList(),entityName,statementList); .)
    .

ConfigurationDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    UseClause<out item>
    | GroupDeclaration<out item>
    | AttributeSpecification<out item>
    )
    .

ConfigurationDeclaration<out ConfigurationDeclaration configDecl> =
    (.ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();.)
    configuration Identifier<out Identifier identifier> of SelectedName<out SelectedName entityName> is
        {ConfigurationDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item);.)}
        BlockConfiguration<out BlockConfiguration blockConfig>
    end [configuration] [UnusedIdentifier] semicolon
    (.configDecl=new ConfigurationDeclaration(identifier,declarativeItems.toList(),entityName,blockConfig);.)
    .

BlockConfigurationIndex<out Either<DiscreteRange,Expression> index> =
    (.index=null;.)
    (
    IF(isDiscreteRangeInBlockConfigurationIndex()) DiscreteRange<out DiscreteRange discreteRange> (.index=new Left<DiscreteRange,Expression>(discreteRange);.)
    | Expression<out Expression expr> (.index=new Right<DiscreteRange,Expression>(expr);.)
    )
    .

BlockSpecification<out BlockConfigurationSpecification blockSpec>  =
    //could be a block_statement_label or generate_statement_label
    (.blockSpec=null;Either<DiscreteRange,Expression> blockIndex=null;.)
    (
    IF(scanner.Peek().kind==_lparen) Identifier<out Identifier identifier> [lparen BlockConfigurationIndex<out blockIndex> rparen]
        (.blockSpec=new BlockConfigurationSpecification(new Right<SelectedName, Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>>(new Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>(identifier,toOption(blockIndex))));.)
    | SelectedName<out SelectedName selectedName> (.blockSpec=new BlockConfigurationSpecification(new Left<SelectedName, Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>>(selectedName));.)
    )
    .

BlockConfiguration<out BlockConfiguration blockConfig> =
    (.
        ListBuffer<UseClause> useClauses=new ListBuffer<UseClause>();
        ListBuffer<Object> configurations=new ListBuffer<Object>();
    .)
    for BlockSpecification<out BlockConfigurationSpecification blockSpec>
    {UseClause<out UseClause useClause> (.useClauses.append(useClause);.)}
    {
        IF(isComponentConfigurationInBlockConfiguration()) ComponentConfiguration<out ComponentConfiguration componentConfiguration> (.configurations.append(componentConfiguration);.)
        | BlockConfiguration<out BlockConfiguration blockConfiguration> (.configurations.append(blockConfiguration);.)
    }
    end for semicolon
    (.blockConfig=new BlockConfiguration(blockSpec,useClauses.toList(),configurations.toList());.)
    .

ComponentConfiguration<out ComponentConfiguration componentConfig> =
    (.BlockConfiguration blockConfiguration=null;Object indication=null;.)
    for ComponentSpecification<out Object componentSpec>
        [BindingIndication<out indication> semicolon]
        [BlockConfiguration<out blockConfiguration>]
    end for semicolon
    (.componentConfig=new ComponentConfiguration(componentSpec,toOption(indication),toOption(blockConfiguration));.)
    .

PackageDeclaration<out PackageDeclaration packageDecl> =
    (. ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>(); .)
    package Identifier<out Identifier identifier> is
        {PackageDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item);.)}
    end [package] [UnusedIdentifier] semicolon
    (.packageDecl=new PackageDeclaration(identifier,declarativeItems.toList());.)
    .

PackageDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclaration<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | SignalDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | ComponentDeclaration<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | DisconnectionSpecification<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

PackageBody<out PackageBodyDeclaration packageBody> =
    (. ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();.)
    package body Identifier<out Identifier identifier> is
        {PackageBodyDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item);.)}
    end [package body] [UnusedIdentifier] semicolon
    (.packageBody = new PackageBodyDeclaration(identifier,declarativeItems.toList());.)
    .

PackageBodyDeclarativeItem <out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | SignalDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

Designator<out Identifier identifier> =
    (.identifier = null;.)
    (
    Identifier<out identifier>
    | stringLiteral (.identifier=toIdentifier(t);.) //stringLiteral is a operator symbol
    )
    .

SubprogramSpecification<out SubProgramDeclaration decl> =
    (.Position pos=toPosition(la);Identifier designator=null;InterfaceList list=null;decl=null;.)
    (
    procedure Designator<out designator> [lparen ParameterInterfaceListProcedure<out list> rparen]
        (.decl=new ProcedureDeclaration(pos,designator,toOption(list));.)
    | (.boolean pure=true;.)[pure | impure(.pure=false;.)] function Designator<out designator> [lparen ParameterInterfaceListFunction<out list> rparen] return TypeMark<out SelectedName returnType>
        (.decl=new FunctionDeclaration(pos,pure,designator,toOption(list),returnType);.)
    )
    .

SubprogramDeclarationOrBody<out DeclarativeItem declOrBody> =
    (.SubProgramDefinition subProgramDef=null;.)
    SubprogramSpecification<out SubProgramDeclaration decl> [SubprogramBody<out subProgramDef,decl>] semicolon
    (. if (subProgramDef!=null) declOrBody=subProgramDef; else declOrBody=decl;.)
    .

SubprogramDeclaration<out DeclarativeItem subprogramDecl> =
	SubprogramSpecification<out subprogramDecl> semicolon
	.

SubprogramBody<out SubProgramDefinition subProgramDef,SubProgramDeclaration subprogramDecl> =
    (. ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>(); .)
    is
        {SubprogramDeclarativeItem<out DeclarativeItem item>(. declarativeItems.append(item); .)}
    begin
        SequentialStatementList<.out Seq<SequentialStatement> sequentialStatements.>
    end [procedure | function] [Designator<out Identifier unused>]
    (.
        if (subprogramDecl instanceof ProcedureDeclaration){
            ProcedureDeclaration procDecl = (ProcedureDeclaration)subprogramDecl;
            subProgramDef=new ProcedureDefinition(subprogramDecl.position(),procDecl.identifier(),procDecl.parameterInterfaceList(),declarativeItems.toList(),sequentialStatements);
        }else {
            FunctionDeclaration funcDecl=(FunctionDeclaration)subprogramDecl;
            subProgramDef=new FunctionDefinition(subprogramDecl.position(),funcDecl.pure(),funcDecl.identifier(),funcDecl.parameterInterfaceList(),funcDecl.returnType(),declarativeItems.toList(),sequentialStatements);
        }
    .)
    .

SubprogramDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

TypeDeclaration<out AbstractTypeDeclaration typeDecl> =
    (.Position pos=toPosition(la);typeDecl=null;.)
    type Identifier<out Identifier id> (
    is TypeDefinition<out typeDecl,id,pos> semicolon
    | semicolon (.typeDecl=new IncompleteTypeDeclaration(pos,id);.)
    )
    .

TypeDefinition<out AbstractTypeDeclaration typeDef,Identifier id,Position pos> =
    (.typeDef=null;.)
    (
    EnumerationTypeDefinition<out typeDef,id,pos>
    | IF(isPhysicalType()) PhysicalTypeDefinition<out typeDef,id,pos>
    | IntegerOrFloatingPointTypeDefinition<out typeDef,id,pos>
    | ArrayTypeDefinition<out typeDef,id,pos>
    | RecordTypeDefinition<out typeDef,id,pos>
    | AccessTypeDefinition<out typeDef,id,pos>
    | FileTypeDefinition<out typeDef,id,pos>
    | IF(la.kind==_protected && scanner.Peek().kind==_body) ProtectedTypeBody<out typeDef,id,pos>
    | ProtectedTypeDeclaration<out typeDef,id,pos>
    )
    .


ConstantDeclaration <out ConstantDeclaration constantDecl> =
    (.Position pos=toPosition(la);Expression expr=null;.)
    constant IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType> [varAssign Expression<out expr>] semicolon
    (.constantDecl=new ConstantDeclaration(pos,list,subType,toOption(expr));.)
    .

SignalDeclaration<out SignalDeclaration signalDecl> =
    (.Position pos=toPosition(la);Expression expr=null;boolean reg=false,bus=false;.)
    signal IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType> [register(.reg=true;.)|bus(.bus=true;.)] [varAssign Expression<out expr>] semicolon
    (.
        SignalType signalType=null;
            if(reg) signalType=SignalType.REGISTER;
            else if (bus) signalType=SignalType.BUS;
        signalDecl=new SignalDeclaration(pos,list,subType,toOption(signalType),toOption(expr));
    .)
    .

VariableDeclaration<out VariableDeclaration varDecl> =
    (.Position pos=toPosition(la);Expression expr=null;boolean shared=false;.)
    [shared(.shared=true;.)] variable IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType> [varAssign Expression<out expr>] semicolon
    (.varDecl=new VariableDeclaration(pos,shared,list,subType,toOption(expr));.)
    .

FileDeclaration<out FileDeclaration fileDecl> =
    (.Position pos=toPosition(la);Expression file_open_kind_expression=null,file_logical_name=null;.)
    file IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType> [[open Expression<out file_open_kind_expression>] is Expression<out file_logical_name>] semicolon
    (.fileDecl=new FileDeclaration(pos,list,subType,toOption(file_open_kind_expression),toOption(file_logical_name));.)
    .

AliasDeclaration<out AliasDeclaration aliasDecl> =
    (.Position pos=toPosition(la);Signature signature=null;SubTypeIndication subType=null;.)
    alias AliasDesignator<out Identifier designator> [colon SubtypeIndication<out subType>] is Name<out Name name> [Signature<out signature>] semicolon
    (.aliasDecl=new AliasDeclaration(pos,designator,toOption(subType),name,toOption(signature));.)
    .

AliasDesignator<out Identifier identifier> =
    (.identifier=null;.)
    (
    Identifier<out identifier>
    | characterLiteral(.identifier=toIdentifier(t);.)
    | stringLiteral(.identifier=toIdentifier(t);.)
    )
    .

ComponentDeclaration<out ComponentDeclaration componentDecl> =
    (.Position pos=toPosition(la);InterfaceList genericClause=null,portClause=null;.)
    component Identifier<out Identifier identifier> [is]
        [GenericClause<out genericClause>]
        [PortClause<out portClause>]
    end component [UnusedIdentifier] semicolon
    (.componentDecl=new ComponentDeclaration(pos,identifier,toOption(genericClause),toOption(portClause));.)
    .

AttributeDeclaration<out AttributeDeclaration attributeDecl> =
    (.Position pos=toPosition(la);.)
    attribute Identifier<out Identifier identifier> colon TypeMark<out SelectedName type> semicolon
    (.attributeDecl=new AttributeDeclaration(pos,identifier,type);.)
    .

AttributeSpecification<out AttributeSpecification node> =
    (.Position pos=toPosition(la);Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> nameList=null;.)
    attribute Identifier<out Identifier identifier> of EntityNameList<out nameList> colon EntityClass<out EntityClass entityClass> is Expression<out Expression expr> semicolon
    (.node=new AttributeSpecification(pos,identifier,nameList,entityClass,expr);.)
    .

EntityDesignator<out Tuple2<Identifier,Option<Signature>> designator> =
    (. Identifier identifier=null; Signature signature=null;.)
    (
    Identifier<out identifier>
    | characterLiteral(.identifier=toIdentifier(t);.)
    | stringLiteral(.identifier=toIdentifier(t);.)
    ) [Signature<out signature>]
    (.designator=new Tuple2<Identifier,Option<Signature>>(identifier,toOption(signature)); .)
    .

EntityNameList<out Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> list> =
    (.
       ListBuffer<Tuple2<Identifier,Option<Signature>>> elements=new ListBuffer<Tuple2<Identifier,Option<Signature>>>();
       Tuple2<Identifier,Option<Signature>> designator=null;
       list=null;
    .)
    (
    EntityDesignator<out designator> (.elements.append(designator); .) {comma EntityDesignator<out designator> (.elements.append(designator);.)}
    (.list=new Left<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(elements.toList());.)
    | others (.list=new Right<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(toIdentifier(t));.)
    | all (.list=new Right<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(toIdentifier(t));.)
    )
    .

EntityClass<out EntityClass entityClass> =
    (.entityClass=null;.)
    (
    entity (.entityClass=EntityClass.ENTITY;.)
    | architecture (.entityClass=EntityClass.ARCHITECTURE;.)
    | configuration (.entityClass=EntityClass.CONFIGURATION;.)
    | package (.entityClass=EntityClass.PACKAGE;.)
    | procedure (.entityClass=EntityClass.PROCEDURE;.)
    | function (.entityClass=EntityClass.FUNCTION;.)
    | type (.entityClass=EntityClass.TYPE;.)
    | subtype (.entityClass=EntityClass.SUBTYPE;.)
    | constant (.entityClass=EntityClass.CONSTANT;.)
    | signal (.entityClass=EntityClass.SIGNAL;.)
    | variable (.entityClass=EntityClass.VARIABLE;.)
    | file (.entityClass=EntityClass.FILE;.)
    | component (.entityClass=EntityClass.COMPONENT;.)
    | label (.entityClass=EntityClass.LABEL;.)
    | literal (.entityClass=EntityClass.LITERAL;.)
    | units (.entityClass=EntityClass.UNITS;.)
    | group (.entityClass=EntityClass.GROUP;.)
    )
    .

ConfigurationSpecification<out ConfigurationSpecification configSpec> =
    (.Position pos=toPosition(la);.)
    for ComponentSpecification<out Object componentSpec>
        BindingIndication<out Object indication> semicolon
    (.configSpec= new ConfigurationSpecification(pos);.)
    .

InstantiationList<out Either<Seq<Identifier>,Identifier> list> =
    (.list=null;.)
    (
    IdentifierList<.out Seq<Identifier> identifierList.> (.list=new Left<Seq<Identifier>,Identifier>(identifierList);.)
    | others (.list=new Right<Seq<Identifier>,Identifier>(toIdentifier(t));.)
    | all (.list=new Right<Seq<Identifier>,Identifier>(toIdentifier(t));.)
    )
    .

ComponentSpecification<out Object spec> =
    InstantiationList<out Object list> colon SelectedName<out SelectedName name>
    (.spec=null;.)
    .

EntityAspect =
    entity SelectedName<out SelectedName entity_name> [lparen Identifier<out Identifier architecture_identifier> rparen]
    | configuration  SelectedName<out SelectedName configuration_name>
    | open
    .

BindingIndication<out Object indication> =
    [use EntityAspect]
    [GenericMapAspect<out AssociationList genericMap>]
    [PortMapAspect<out AssociationList portMap>]
    (.indication=null;.)
    .

DisconnectionSpecification<out DisconnectionSpecification disconnectSpec> =
    (.Position pos=toPosition(la);Identifier id=null;Seq<SelectedName> list=null;.)
    disconnect (SelectedNameList<out list> | others(.id=toIdentifier(t);.) | all (.id=toIdentifier(t);.)) colon TypeMark<out SelectedName type> after Expression<out Expression expr> semicolon
    (.disconnectSpec= new DisconnectionSpecification(pos,id==null?new Left<Seq<SelectedName>,Identifier>(list):new Right<Seq<SelectedName>,Identifier>(id),type,expr);.)
    .

EntityClassEntry<out at.jku.ssw.openvc.ast.declarations.GroupTemplateDeclaration.Element entry> =
    (.boolean box=false;.)
    EntityClass<out EntityClass  entityClass> [box(.box=true;.)]
    (.entry = new GroupTemplateDeclaration.Element(entityClass,box);.)
    .

GroupTemplateDeclaration<out GroupTemplateDeclaration groupTemplateDecl> =
    (.
        Position pos=toPosition(la);
        ListBuffer<GroupTemplateDeclaration.Element> elements=new ListBuffer<GroupTemplateDeclaration.Element>();
    .)
    group Identifier<out Identifier identifier> is lparen EntityClassEntry<out GroupTemplateDeclaration.Element entry> (.elements.append(entry);.) {comma EntityClassEntry<out entry> (.elements.append(entry);.)}  rparen semicolon
    (.groupTemplateDecl=new GroupTemplateDeclaration(pos,identifier,elements.toList());.)
    .

GroupDeclaration<out GroupDeclaration groupDecl> =
    (.Position pos=toPosition(la);Seq<Either<Name,Identifier>> list=null;.)
    group Identifier<out Identifier identifier> colon SelectedName<out SelectedName selectedName> lparen GroupConstituentList<out list> rparen semicolon
    (.groupDecl=new GroupDeclaration(pos,identifier,selectedName,list);.)
    .

GroupConstituent<out Either<Name,Identifier> constituent> =
	(.constituent=null;.)
	(
    Name<out Name name> (.constituent=new Left<Name,Identifier>(name);.)
    | characterLiteral (.constituent=new Right<Name,Identifier>(toIdentifier(t));.)
    )
    .

GroupConstituentList<out Seq<Either<Name,Identifier>> list> =
    (.
        ListBuffer<Either<Name,Identifier>> elements=new ListBuffer<Either<Name,Identifier>>();
        Either<Name,Identifier> element=null;
    .)
    GroupConstituent<out element> (.elements.append(element); .) {comma GroupConstituent<out element> (.elements.append(element);.)}
    (.list=elements.toList();.)
    .

UseClause<out UseClause useClause> =
    (.Position pos=toPosition(la);.)
    use SelectedNameList<.out Seq<SelectedName> list.> semicolon
    (.useClause=new UseClause(pos,list);.)
    .

EnumerationLiteral<out Identifier identifier> =
    (.identifier=null;.)
    (
    Identifier<out identifier>
    | characterLiteral (.identifier=toIdentifier(t);.)
    )
    .

EnumerationTypeDefinition<out EnumerationTypeDefinition enumTypeDef,Identifier id,Position pos> =
    (.
        ListBuffer<Identifier> elements=new ListBuffer<Identifier>();
        Identifier element=null;
    .)
    lparen EnumerationLiteral<out element> (.elements.append(element);.){comma EnumerationLiteral<out element> (.elements.append(element);.)} rparen
    (.enumTypeDef=new EnumerationTypeDefinition(pos,id,elements.toList());.)
    .

IntegerOrFloatingPointTypeDefinition<out IntegerOrFloatingPointTypeDefinition intOrFloat,Identifier id,Position pos> =
    range Range<out Range range>
    (.intOrFloat=new IntegerOrFloatingPointTypeDefinition(pos,id,range);.)
    .

PhysicalTypeDefinition<out PhysicalTypeDefinition physicalTypeDef, Identifier id,Position pos> =
    (. ListBuffer<PhysicalTypeDefinition.Element> elements=new ListBuffer<PhysicalTypeDefinition.Element>(); .)
    range Range<out Range range>
    units
        Identifier<out Identifier baseIdentifier> semicolon
        {
        Identifier<out Identifier identifier> eq PhysicalLiteral<out PhysicalLiteral literal> semicolon
        (.elements.append(new PhysicalTypeDefinition.Element(identifier,literal));.)
        }
    end units [UnusedIdentifier]
    (.physicalTypeDef=new PhysicalTypeDefinition(pos,id,range,baseIdentifier,elements.toList());.)
    .

IndexSubtypeDefinition<out SelectedName typeMark> =
    TypeMark<out typeMark> range box
    .

ArrayTypeDefinition<out AbstractArrayTypeDefinition arrayTypeDef,Identifier id,Position pos> =
    (.
        ListBuffer<SelectedName> unConstraintList=new ListBuffer<SelectedName>();
        SubTypeIndication subType=null;
        Seq<DiscreteRange> ranges =null;
        SelectedName type=null;
    .)
    array (
    IF(isIndexSubtypeDefinition()) lparen IndexSubtypeDefinition<out type> (.unConstraintList.append(type);.) {comma IndexSubtypeDefinition<out type> (.unConstraintList.append(type);.)} rparen of SubtypeIndication<out subType>
    | IndexConstraint<out ranges> of SubtypeIndication<out subType>
    )
    (.
        if (unConstraintList.isEmpty()) arrayTypeDef=new ConstrainedArrayTypeDefinition(pos,id,ranges,subType);
        else arrayTypeDef=new UnconstrainedArrayTypeDefinition(pos,id,unConstraintList.toList(),subType);
    .)
    .

RecordTypeDefinition<out RecordTypeDefinition recordTypeDef,Identifier id,Position pos> =
    (. ListBuffer<RecordTypeDefinition.Element> elements=new ListBuffer<RecordTypeDefinition.Element>(); .)
    record
        IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType> semicolon
        (.elements.append(new RecordTypeDefinition.Element(list, subType));.)
        {
        IdentifierList<.out list.> colon SubtypeIndication<out subType> semicolon
        (.elements.append(new RecordTypeDefinition.Element(list, subType));.)
        }
    end record [UnusedIdentifier]
    (.recordTypeDef=new RecordTypeDefinition(pos,id,elements.toList());.)
    .

AccessTypeDefinition<out AccessTypeDefinition accessTypeDef,Identifier id,Position pos> =
    access SubtypeIndication<out SubTypeIndication subType>
    (.accessTypeDef=new AccessTypeDefinition(pos,id,subType);.)
    .

FileTypeDefinition<out FileTypeDefinition fileTypeDef,Identifier id,Position pos> =
    file of TypeMark<out SelectedName type>
    (.fileTypeDef=new FileTypeDefinition(pos,id,type);.)
    .

ProtectedTypeDeclaration<out ProtectedTypeDeclaration protectedTypeDecl,Identifier id,Position pos> =
    (. ListBuffer<DeclarativeItem> items=new ListBuffer<DeclarativeItem>(); .)
    protected
        {ProtectedTypeDeclarativeItem<out DeclarativeItem item>(.items.append(item);.)}
    end protected [UnusedIdentifier]
    (.protectedTypeDecl=new ProtectedTypeDeclaration(pos,id,items.toList());.)
    .

ProtectedTypeDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclaration<out item>
    | AttributeSpecification<out item>
    | UseClause<out item>
    )
    .

ProtectedTypeBody<out ProtectedTypeBodyDeclaration protectedTypeBody,Identifier id,Position pos> =
    (. ListBuffer<DeclarativeItem> items=new ListBuffer<DeclarativeItem>(); .)
    protected body
        {ProtectedTypeBodyDeclarativeItem<out DeclarativeItem item>(.items.append(item);.)}
    end protected body [UnusedIdentifier]
    (.protectedTypeBody=new ProtectedTypeBodyDeclaration(pos,id,items.toList());.)
    .

ProtectedTypeBodyDeclarativeItem<out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

SubtypeDeclaration<out SubTypeDeclaration subTypeDecl> =
    (.Position pos=toPosition(la);.)
    subtype Identifier<out Identifier identifier> is SubtypeIndication<out SubTypeIndication subType> semicolon
    (.subTypeDecl=new SubTypeDeclaration(pos,identifier,subType);.)
    .

SubtypeIndication<out SubTypeIndication subType> =
    (.Either<Range,Seq<DiscreteRange>> constraint=null;SelectedName n2=null;.)
    SelectedName<out SelectedName n1> [SelectedName<out n2>] [Constraint<out constraint>]
    (.
        if (n2!=null) subType=new SubTypeIndication(toOption(n1),n2,toOption(constraint));
        else subType=new SubTypeIndication(n1,toOption(constraint));
    .)
    .

Direction<out Direction rangeDirection> =
    (.rangeDirection=null;.)
    (
    to (.rangeDirection=Direction.To;.)
    | downto (.rangeDirection=Direction.Downto;.)
    )
    .

RangeConstraint<out Range rangeConstraint> =
    range Range<out rangeConstraint>
    .

IndexConstraint<out Seq<DiscreteRange> ranges> =
    (.
        ListBuffer<DiscreteRange> list=new ListBuffer<DiscreteRange>();
        DiscreteRange discreteRange=null;
    .)
    lparen DiscreteRange<out discreteRange> (.list.append(discreteRange);.) {comma  DiscreteRange<out discreteRange> (.list.append(discreteRange);.)} rparen
    (.ranges = list.toList();.)
    .

Range<out Range range> =
    (.range=null;.)
    (
    IF(isNotNameInRange()) SimpleExpression<out Expression from> Direction<out Direction rangeDirection>  SimpleExpression<out Expression to> (.range =new Range(from,rangeDirection,to);.)
    | Name<out Name name> (.range =new Range(null,null,null,toOption(name));.)
    )
    .

Constraint<out Either<Range,Seq<DiscreteRange>> constraint> =
    (.constraint=null;.)
    (
    RangeConstraint<out Range rangeContraint> (.constraint = new Left<Range,Seq<DiscreteRange>>(rangeContraint);.)
    | IndexConstraint<.out Seq<DiscreteRange> ranges.> (.constraint = new Right<Range,Seq<DiscreteRange>>(ranges);.)
    )
    .

DiscreteRange<out DiscreteRange discreteRange> =
    (.discreteRange=null;.)
    (
    IF(isSubtypeIndicationInDiscreteRange()) SubtypeIndication<out SubTypeIndication subType> (.discreteRange=new DiscreteRange(new Right<Range, SubTypeIndication>(subType));.)
    | Range<out Range range> (.discreteRange=new DiscreteRange(new Left<Range, SubTypeIndication>(range));.)
    )
    .

TypeMark<out SelectedName typeName> =
    SelectedName<out typeName> // could be type_name or subtype_name;
    .

ArchitectureStatementList<out Seq<ConcurrentStatement> list> =
    (.ListBuffer<ConcurrentStatement> statementList=new ListBuffer<ConcurrentStatement>();.)
    {ArchitectureStatement<out ConcurrentStatement stmt> (.statementList.append(stmt);.)}
    (.list=statementList.toList();.)
    .

ArchitectureStatement<out ConcurrentStatement concurrentStmt> =
    (.concurrentStmt=null; Identifier label=null;.)
    (
    IF(scanner.Peek().kind==_colon) LabelColon<out label> (
        IF(isArchitectureStatementWithLabel()) ArchitectureStatementWithLabel<out concurrentStmt,label>
        | ArchitectureStatementOptionalLabel<out concurrentStmt,label>
        )
    | ArchitectureStatementOptionalLabel<out concurrentStmt,label>
    )
    .

ArchitectureStatementWithLabel<out ConcurrentStatement concurrentStmt, Identifier label> =
    (.concurrentStmt=null;.)
    (
    ComponentInstantiationStatement<out concurrentStmt,label>
    | BlockStatement<out concurrentStmt,label>
    | GenerateStatement<out concurrentStmt,label>
    )
    .

ArchitectureStatementOptionalLabel<out ConcurrentStatement concurrentStmt, Identifier label> =
    (.concurrentStmt=null;boolean postponed=false;.)
    [postponed(.postponed=true;.)]
    (
    ProcessStatement<out concurrentStmt,label,postponed>
    | ConcurrentAssertionStatement<out concurrentStmt,label,postponed>
    | IF(isConcurrentSignalAssignmentStatement()) ConcurrentSignalAssignmentStatement<out concurrentStmt,label,postponed>
    | ConcurrentProcedureCallStatement<out concurrentStmt,label,postponed>
    )
    .

GenericMapAspect<out AssociationList associationList> =
    generic map lparen AssociationList<out associationList> rparen
    .

PortMapAspect<out AssociationList associationList> =
    port map lparen AssociationList<out associationList> rparen
    .

BlockStatement<out BlockStatement blockStmt, Identifier label> =
    (.
        Position pos=toPosition(la);
        ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();
        Expression guard_expression=null;
        InterfaceList genericClause=null,portClause=null;
        AssociationList genericMap=null,portMap=null;
    .)
    block [lparen Expression<out guard_expression> rparen] [is]
        [GenericClause<out genericClause> [GenericMapAspect<out genericMap> semicolon]]
        [PortClause<out portClause> [PortMapAspect<out portMap> semicolon]]
        {BlockDeclarativeItem<out DeclarativeItem item>(. declarativeItems.append(item);.)}
    begin
        ArchitectureStatementList<.out Seq<ConcurrentStatement> statementList.>
    end block [UnusedIdentifier] semicolon
    (. blockStmt=new BlockStatement(pos,toOption(label),toOption(guard_expression),toOption(genericClause),toOption(genericMap),toOption(portClause),toOption(portMap),declarativeItems.toList(),statementList);.)
    .

BlockDeclarativeItem <out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | SignalDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | ComponentDeclaration<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | ConfigurationSpecification<out item>
    | DisconnectionSpecification<out item>
    | UseClause<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

ProcessStatement<out ProcessStatement processStmt,Identifier label,boolean postponed> =
    (.
        Position pos=toPosition(la);
        ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();
        Seq<Name> NameList=null;
    .)
    process [lparen NameList<out NameList> rparen] [is]
        {ProcessDeclarativeItem<out DeclarativeItem item> (.declarativeItems.append(item);.)}
    begin
        SequentialStatementList<.out Seq<SequentialStatement> sequentialStatements.>
    end [postponed] process [UnusedIdentifier] semicolon
    (.processStmt=new ProcessStatement(pos,toOption(label),postponed,toOption(NameList),declarativeItems.toList(),sequentialStatements);.)
    .

ProcessDeclarativeItem <out DeclarativeItem item> =
    (.item=null;.)
    SYNC
    (
    SubprogramDeclarationOrBody<out item>
    | TypeDeclaration<out item>
    | SubtypeDeclaration<out item>
    | ConstantDeclaration<out item>
    | VariableDeclaration<out item>
    | FileDeclaration<out item>
    | AliasDeclaration<out item>
    | UseClause<out item>
    | IF(isAttributeDeclaration()) AttributeDeclaration<out item>
    | AttributeSpecification<out item>
    | IF(isGroupTemplate()) GroupTemplateDeclaration<out item>
    | GroupDeclaration<out item>
    )
    .

ConcurrentProcedureCallStatement<out ConcurrentProcedureCallStatement procedureCallStmt, Identifier label,boolean postponed> =
    (.AssociationList paramterList=null;.)
    SelectedName<out SelectedName procedure_name> [lparen AssociationList<out paramterList>  rparen] semicolon
    (.procedureCallStmt=new ConcurrentProcedureCallStatement(toOption(label),postponed,procedure_name,toOption(paramterList));.)
    .

ConcurrentAssertionStatement<out ConcurrentAssertionStatement assertStmt, Identifier label,boolean postponed> =
    (.Position pos=toPosition(la);Expression report_expression=null,severity_expression=null;.)
    assert Condition<out Expression expr>  [report Expression<out report_expression>] [severity Expression<out severity_expression>] semicolon
    (.assertStmt=new ConcurrentAssertionStatement(pos,toOption(label),postponed,expr,toOption(report_expression),toOption(severity_expression));.)
    .

ConcurrentSignalAssignmentStatement<out ConcurrentSignalAssignmentStatement signalAssignmentStatement, Identifier label,boolean postponed> =
    (.signalAssignmentStatement=null;.)
    (
    ConditionalSignalAssignment<out signalAssignmentStatement,label,postponed>
    | SelectedSignalAssignment<out signalAssignmentStatement,label,postponed>
    )
    .

ConditionalSignalAssignment<out ConcurrentConditionalSignalAssignment signalAssignment, Identifier label,boolean postponed> =
    (.
        ListBuffer<ConcurrentConditionalSignalAssignment.When> elements=new ListBuffer<ConcurrentConditionalSignalAssignment.When>();
        boolean guarded=false;
        DelayMechanism delay=null;
    .)
    Target<out Target target> leq (.Position pos=toPosition(t);.) [guarded(.guarded=true;.)] [DelayMechanism<out delay>]
        ConditionalWaveforms<elements>
        semicolon
    (.signalAssignment=new ConcurrentConditionalSignalAssignment(pos,toOption(label),postponed,target,guarded,toOption(delay),elements.toList());.)
    .

ConditionalWaveforms<.ListBuffer<ConcurrentConditionalSignalAssignment.When> elements.> =
    (.Expression expr=null;.)
    Waveform<out Waveform waveform> [ when Condition<out expr> [ else ConditionalWaveforms<elements> ] ] (.elements.prepend(new ConcurrentConditionalSignalAssignment.When(waveform,expr));.)
    .

SelectedWaveform<out ConcurrentSelectedSignalAssignment.When whenClause> =
    Waveform<out Waveform waveform> when Choices<out Choices choices> (.whenClause = new ConcurrentSelectedSignalAssignment.When(waveform,choices);.)
    .

SelectedSignalAssignment<out ConcurrentSelectedSignalAssignment signalAssignment,Identifier label,boolean postponed> =
    (.
        Position pos=toPosition(la);
        ListBuffer<ConcurrentSelectedSignalAssignment.When> elements=new ListBuffer<ConcurrentSelectedSignalAssignment.When>();
        boolean guarded=false;
        ConcurrentSelectedSignalAssignment.When when=null;
        DelayMechanism delay=null;
    .)
    with Expression<out Expression expr> select
        Target<out Target target> leq [guarded(.guarded=true;.)] [DelayMechanism<out delay>]
        SelectedWaveform<out when> (.elements.append(when);.){comma SelectedWaveform<out when>(.elements.append(when);.)} semicolon
        (.signalAssignment=new ConcurrentSelectedSignalAssignment(pos,toOption(label),postponed,expr,target,guarded,toOption(delay),elements.toList());.)
        .

Target<out Target target> =
    (.target=null;.)
    (
    Name<out Name name> (.target = new Target(new Left<Name, Aggregate>(name));.)
    | Aggregate<out Aggregate aggregate> (.target = new Target(new Right<Name, Aggregate>(aggregate));.)
    )
    .

ComponentInstantiationStatement<out ComponentInstantiationStatement stmt, Identifier label> =
    (.
        ComponentType componentType =null;
        AssociationList genericMap=null,portMap=null;
        Position pos=toPosition(la);
        SelectedName name=null;
        Identifier architecture=null;
    .)
    (
    [component] SelectedName<out name> (.componentType=ComponentType.COMPONENT;.)
    | entity SelectedName<out name> [lparen Identifier<out architecture> rparen] (.componentType=ComponentType.ENTITY;.)
    | configuration SelectedName<out name> (.componentType=ComponentType.CONFIGURATION;.)
    )
    [GenericMapAspect<out genericMap>]
    [PortMapAspect<out portMap>] semicolon
    (.stmt=new ComponentInstantiationStatement(pos,label,componentType,name,toOption(architecture),toOption(genericMap),toOption(portMap));.)
    .

GenerateStatement<out ConcurrentStatement generateStmt, Identifier label> =
    (.generateStmt=null;.)
    (
    ForGenerateStatement<out generateStmt, label>
    | IfGenerateStatement<out generateStmt, label>
    )
    .

ForGenerateStatement<out ForGenerateStatement forGenerateStmt, Identifier label> =
    (.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
    for Identifier<out Identifier loopIdentifier> in DiscreteRange<out DiscreteRange discreteRange> generate
        GenerateStatementBody<out body>
    end generate [UnusedIdentifier] semicolon
    (.forGenerateStmt=new ForGenerateStatement(pos,toOption(label),loopIdentifier,discreteRange,body._1,body._2);.)
    .

IfGenerateStatement<out IfGenerateStatement ifGenerateStmt, Identifier label> =
    (.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
    if Condition<out Expression expr> generate
        GenerateStatementBody<out body>
    end generate [UnusedIdentifier] semicolon
    (.ifGenerateStmt=new IfGenerateStatement(pos,toOption(label),expr,body._1,body._2);.)
    .

GenerateStatementBody<out Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> statementList> =
    (.ListBuffer<DeclarativeItem> declarativeItems=new ListBuffer<DeclarativeItem>();.)
    [{BlockDeclarativeItem<out DeclarativeItem item>(.declarativeItems.append(item);.)}
    begin]
    ArchitectureStatementList<.out Seq<ConcurrentStatement> concurrentStatements.>
    (.statementList=new Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>>(declarativeItems.toList(),concurrentStatements);.)
    .

SequentialStatementList<out Seq<SequentialStatement> list> =
    (.ListBuffer<SequentialStatement> tmpList=new ListBuffer<SequentialStatement>();.)
    {SequentialStatement<out SequentialStatement stmt>(.tmpList.append(stmt);.)}
    (.list=tmpList.toList();.)
    .

SequentialStatement<out SequentialStatement sequentialStatement> =
    (.sequentialStatement=null;Identifier label=null;.)
    (
    [IF(scanner.Peek().kind==_colon) LabelColon<out label>] SYNC
    (
    WaitStatement<out sequentialStatement,label>
    | AssertionStatement<out sequentialStatement,label>
    | ReportStatement<out sequentialStatement,label>
    | IfStatement<out sequentialStatement,label>
    | CaseStatement<out sequentialStatement,label>
    | LoopStatement<out sequentialStatement,label>
    | NextStatement<out sequentialStatement,label>
    | ExitStatement<out sequentialStatement,label>
    | ReturnStatement<out sequentialStatement,label>
    | NullStatement<out sequentialStatement,label>
    | IF(isAssignmentStatement()) SignalOrVariableAssignmentStatement<out sequentialStatement,label>
    | ProcedureCallStatement<out sequentialStatement,label>
    )
    )
    .

WaitStatement<out WaitStatement waitStmt, Identifier label> =
    (.Position pos=toPosition(la);Expression untilExpr=null,forExpression=null;Seq<Name> NameList=null;.)
    wait [on NameList<out NameList>] [until Condition<out untilExpr>] [for Expression<out forExpression>] semicolon
    (.waitStmt=new WaitStatement(pos,toOption(label),toOption(NameList),toOption(untilExpr),toOption(forExpression));.)
    .

AssertionStatement<out AssertStatement assertStmt, Identifier label> =
    (.Position pos=toPosition(la);Expression report_expression=null, severity_expression= null;.)
    assert Condition<out Expression expr> [report Expression<out report_expression>] [severity Expression<out severity_expression>] semicolon
    (.assertStmt=new AssertStatement(pos,toOption(label),expr,toOption(report_expression),toOption(severity_expression));.)
    .

ReportStatement<out ReportStatement reportStmt, Identifier label> =
    (.Position pos=toPosition(la);Expression severity_expression=null;.)
    report Expression<out Expression report_expression> [severity Expression<out severity_expression>] semicolon
    (.reportStmt=new ReportStatement(pos,toOption(label),report_expression,toOption(severity_expression));.)
    .

SignalOrVariableAssignmentStatement<out SequentialStatement statement,Identifier label> =
    (.statement=null;.)
    Target<out Target target>
    (
        SignalAssignmentStatement<out statement,label,target>
        | VariableAssignmentStatement<out statement,label,target>
    )
    .

VariableAssignmentStatement<out VariableAssignmentStatement varAssignStmt,Identifier label,Target target> =
    varAssign (.Position pos=toPosition(t);.) Expression<out Expression expr> semicolon
    (.varAssignStmt=new SimpleVariableAssignmentStatement(pos,toOption(label),target,expr);.)
    .

SignalAssignmentStatement<out SignalAssignmentStatement signalAssignStmt, Identifier label,Target target> =
    (.DelayMechanism delay=null;.)
    leq (.Position pos=toPosition(t);.)[DelayMechanism<out delay>] Waveform<out Waveform waveform> semicolon
    (.signalAssignStmt=new SimpleSignalAssignmentStatement(pos,toOption(label),target,toOption(delay),waveform);.)
    .

DelayMechanism<out DelayMechanism mechanism> =
    (.Expression time_expression=null;.)
    (
    transport
    | [reject Expression<out time_expression>] inertial
    )
    (.
        if (time_expression==null) mechanism=new DelayMechanism(DelayType.TRANSPORT,toOption(time_expression));
        else mechanism=new DelayMechanism(DelayType.INERTIAL,toOption(time_expression));
    .)
    .

WaveformElement<out at.jku.ssw.openvc.ast.Waveform.Element element> =
	(.Expression time_expression=null;.)
 	Expression<out Expression value_expression> [after Expression<out time_expression>]
 	(.element= new Waveform.Element(value_expression,toOption(time_expression));.)
 	.

Waveform<out Waveform waveForm> =
    (.ListBuffer<Waveform.Element> elements=new ListBuffer<Waveform.Element>();.)
    (
    WaveformElement<out Waveform.Element element>(.elements.append(element);.) {comma WaveformElement<out element>(.elements.append(element);.)}
    | unaffected
    )
    (.waveForm=new Waveform(elements.toList());.)
    .

ProcedureCallStatement<out ProcedureCallStatement procedureCallStmt, Identifier label> =
    (.AssociationList paramterList=null;.)
    SelectedName<out SelectedName procedure_name> [lparen AssociationList<out paramterList> rparen] semicolon
    (.procedureCallStmt=new ProcedureCallStatement(toOption(label),procedure_name,toOption(paramterList));.)
    .

IfStatement<out IfStatement ifStmt, Identifier label> =
    (.
        Position pos=toPosition(la);
        ListBuffer<IfStatement.IfThenPart> ifList=new ListBuffer<IfStatement.IfThenPart>();
        Seq<SequentialStatement> sequentialStatements = null;
        Seq<SequentialStatement> else_sequential_statement = null;
    .)
    if Condition<out Expression if_condition> then
        SequentialStatementList<out sequentialStatements> (.ifList.append(new IfStatement.IfThenPart(if_condition,sequentialStatements));.)
    {ELSIF Condition<out Expression elsif_condition> then
         SequentialStatementList<out sequentialStatements>
         (.ifList.append(new IfStatement.IfThenPart(elsif_condition,sequentialStatements));.)
         }
    [else
        SequentialStatementList<out else_sequential_statement>]
    end if [UnusedIdentifier] semicolon
    (.ifStmt=new IfStatement(pos,toOption(label),ifList.toList(),toOption(else_sequential_statement));.)
    .

CaseStatement<out CaseStatement caseStmt,Identifier label> =
    (.
        Position pos=toPosition(la);
        ListBuffer<CaseStatement.When> alternatives=new ListBuffer<CaseStatement.When>();
    .)
    case Expression<out Expression expr> is
        when Choices<out Choices choices> arrow SequentialStatementList<.out Seq<SequentialStatement> sequentialStatements.> (.alternatives.append(new CaseStatement.When(choices,sequentialStatements));.)
        {when Choices<out choices> arrow SequentialStatementList<.out sequentialStatements.> (.alternatives.append(new CaseStatement.When(choices,sequentialStatements));.)}
    end case  [UnusedIdentifier] semicolon
    (.caseStmt=new CaseStatement(pos,toOption(label),expr,alternatives.toList());.)
    .

IterationScheme<out Either<Expression,Tuple2<Identifier,DiscreteRange>> scheme> =
    (.scheme=null;.)
    (
    while Condition<out Expression expr> (.scheme=new Left<Expression,Tuple2<Identifier,DiscreteRange>>(expr);.)
    | for Identifier<out Identifier identifier> in DiscreteRange<out DiscreteRange discreteRange> (.scheme=new Right<Expression,Tuple2<Identifier,DiscreteRange>>(new Tuple2<Identifier,DiscreteRange>(identifier,discreteRange));.)
    )
    .

LoopStatement<out SequentialStatement loopStmt, Identifier label> =
    (.Position pos=toPosition(la);Either<Expression,Tuple2<Identifier,DiscreteRange>> stmtType=null;.)
    [IterationScheme<out stmtType>] loop
        SequentialStatementList<.out Seq<SequentialStatement> sequentialStatements.>
    end loop [UnusedIdentifier] semicolon
    (.
        if (stmtType!=null){
            if (stmtType instanceof Left) loopStmt=new WhileStatement(pos,toOption(label),((Left<Expression,Tuple2<Identifier,DiscreteRange>>)stmtType).a,sequentialStatements);
            else {
                Tuple2<Identifier,DiscreteRange> r=((Right<Expression,Tuple2<Identifier,DiscreteRange>>)stmtType).b;
                loopStmt=new ForStatement(pos,toOption(label),r._1,r._2,sequentialStatements);
            }
        }else loopStmt=new LoopStatement(pos,toOption(label),sequentialStatements);
    .)
    .

NextStatement<out NextStatement nextStmt,Identifier label> =
    (.Position pos=toPosition(la);Identifier identifier=null;Expression expr=null;.)
    next [Identifier<out identifier>] [when Condition<out expr>] semicolon
    (.nextStmt=new NextStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
    .

ExitStatement<out ExitStatement exitStmt, Identifier label> =
    (.Position pos=toPosition(la);Expression expr=null;Identifier identifier=null;.)
    exit [Identifier<out identifier>] [when Condition<out expr>] semicolon
    (.exitStmt=new ExitStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
    .

ReturnStatement<out ReturnStatement returnStmt, Identifier label> =
    (.Position pos=toPosition(la);Expression expr=null;.)
    return [Expression<out expr>] semicolon
    (.returnStmt=new ReturnStatement(pos,toOption(label),toOption(expr));.)
    .

NullStatement<out NullStatement nullStmt, Identifier label> =
    (.Position pos=toPosition(la);.)
    null semicolon
    (.nullStmt=new NullStatement(pos,toOption(label));.)
    .

InterfaceElementProcedure<out InterfaceList.AbstractInterfaceElement element> =
    (.element=null;.)
    (
    IF(isInterfaceConstantDeclaration()) InterfaceConstantDeclaration<out element>
    | IF(isInterfaceVariableDeclaration()) InterfaceVariableDeclaration<out element>
    | InterfaceSignalDeclarationProcedure<out element>
    | InterfaceFileDeclaration<out element>
    )
    .

InterfaceElementFunction<out InterfaceList.AbstractInterfaceElement element> =
    (.element=null;.)
    (
    InterfaceConstantDeclaration<out element>
    | InterfaceSignalDeclarationFunction<out element>
    | InterfaceFileDeclaration<out element>
    )
    .

ParameterInterfaceListProcedure<out InterfaceList list> =
    (.
        ListBuffer<InterfaceList.AbstractInterfaceElement> elements=new ListBuffer<InterfaceList.AbstractInterfaceElement>();
        InterfaceList.AbstractInterfaceElement element=null;
    .)
    InterfaceElementProcedure<out element>(.elements.append(element);.) {semicolon InterfaceElementProcedure<out element> (.elements.append(element);.)}
    (.list=new InterfaceList(elements.toList());.)
    .

ParameterInterfaceListFunction<out InterfaceList list> =
    (.
        ListBuffer<InterfaceList.AbstractInterfaceElement> elements=new ListBuffer<InterfaceList.AbstractInterfaceElement>();
        InterfaceList.AbstractInterfaceElement element=null;
    .)
    InterfaceElementFunction<out element> (.elements.append(element);.) {semicolon InterfaceElementFunction<out element> (.elements.append(element);.)}
    (.list=new InterfaceList(elements.toList());.)
    .

InterfaceConstantDeclaration<out InterfaceList.InterfaceConstantDeclaration constElement> =
    (.Expression expr=null;.)
    [constant] IdentifierList<.out Seq<Identifier> list.> colon [in] SubtypeIndication<out SubTypeIndication subType> [varAssign Expression<out expr>]
    (.constElement=new InterfaceList.InterfaceConstantDeclaration(list,subType,toOption(expr));.)
    .

InterfaceSignalDeclarationProcedure<out InterfaceList.InterfaceSignalDeclaration signalElement> =
    (.Expression expr=null;boolean bus=false;InterfaceMode mode=null;.)
    [signal] IdentifierList<.out Seq<Identifier> list.> colon [InterfaceMode<out mode>] SubtypeIndication<out SubTypeIndication subType> [bus(.bus=true;.)] [varAssign Expression<out expr>]
    (.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(mode),subType,bus,toOption(expr));.)
    .

InterfaceSignalDeclarationFunction<out InterfaceList.InterfaceSignalDeclaration signalElement> =
    (.Expression expr=null;boolean bus=false;.)
    signal IdentifierList<.out Seq<Identifier> list.> colon [in] SubtypeIndication<out SubTypeIndication subType> [bus(.bus=true;.)] [varAssign Expression<out expr>]
    (.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(InterfaceMode.IN),subType,bus,toOption(expr));.)
    .

InterfaceVariableDeclaration<out InterfaceList.InterfaceVariableDeclaration varElement> =
    (.Expression expr=null;InterfaceMode mode=null;.)
    [variable] IdentifierList<.out Seq<Identifier> list.> colon [InterfaceMode<out mode>] SubtypeIndication<out SubTypeIndication subType> [varAssign Expression<out expr>]
    (.varElement=new InterfaceList.InterfaceVariableDeclaration(list,toOption(mode),subType,toOption(expr));.)
    .

InterfaceMode<out InterfaceMode mode> =
    (.mode=null;.)
    (
    in (.mode=InterfaceMode.IN;.)
    | outToken (.mode=InterfaceMode.OUT;.)
    | inout (.mode=InterfaceMode.INOUT;.)
    | buffer (.mode=InterfaceMode.BUFFER;.)
    | linkage (.mode=InterfaceMode.LINKAGE;.)
    )
    .

InterfaceFileDeclaration<out InterfaceList.InterfaceFileDeclaration fileElement> =
    file IdentifierList<.out Seq<Identifier> list.> colon SubtypeIndication<out SubTypeIndication subType>
    (.fileElement=new InterfaceList.InterfaceFileDeclaration(list,subType);.)
    .

AssociationElement<out at.jku.ssw.openvc.ast.AssociationList.Element element> =
    (.Name name=null;Option<Expression> actualPart=null;.)
    [IF(isFormalPartInAssociationElement()) FormalPart<out name> arrow] ActualPart<out actualPart> (.element=new AssociationList.Element(toOption(name),actualPart);.)
    .

AssociationList<out AssociationList list> =
    (.
        ListBuffer<AssociationList.Element> elements=new ListBuffer<AssociationList.Element>();
        AssociationList.Element element=null;
    .)
    AssociationElement<out element> (.elements.append(element);.) {comma AssociationElement<out element> (.elements.append(element);.)}
    (.list=new AssociationList(elements.toList());.)
    .

FormalPart<out Name formalPart> =
    Name<out formalPart>
    .

ActualPart<out Option<Expression> actualPart> =
    (.Expression expr=null;.)
    (
    Expression<out expr>
    | open
    )
    (.actualPart = toOption(expr);.)
    .

Condition<out Expression expr> =
    Expression<out expr>
    .

Expression<out Expression expr> =
    (.Tuple2<Position,Operators.Logical> op=null;.)
    Relation<out expr>
    {LogicalOperator<out op> Relation<out Expression right> (.expr=new LogicalExpression(op._1,expr,op._2,right);.)}
    .

LogicalOperator<out Tuple2<Position,Operators.Logical> op> =
    (.
        Position pos=toPosition(la);
        Operators.Logical logOp=null;
    .)
    (
    and (.logOp=Operators.Logical.AND;.)
    | or (.logOp=Operators.Logical.OR;.)
    | xor (.logOp=Operators.Logical.XOR;.)
    | xnor (.logOp=Operators.Logical.XNOR;.)
    | nand (.logOp=Operators.Logical.NAND;.)
    | nor (.logOp=Operators.Logical.NOR;.)
    )
    (.op=new Tuple2<Position,Operators.Logical>(pos,logOp);.)
    .

Relation<out Expression rel> =
	(.Tuple2<Position,Operators.Relation> op=null;.)
    ShiftExpression<out rel>
    [RelationalOperator<out op> ShiftExpression<out Expression right> (.rel=new Relation(op._1,rel,op._2,right);.)]
    .

RelationalOperator<out Tuple2<Position,Operators.Relation> op> =
    (.
        Position pos=toPosition(la);
        Operators.Relation relOp=null;
    .)
    (
    eq (.relOp=Operators.Relation.EQ;.)
    | neq (.relOp=Operators.Relation.NEQ;.)
    | lt (.relOp=Operators.Relation.LT;.)
    | leq (.relOp=Operators.Relation.LEQ;.)
    | gt (.relOp=Operators.Relation.GT;.)
    | geq (.relOp=Operators.Relation.GEQ;.)
    )
    (.op=new Tuple2<Position,Operators.Relation>(pos,relOp);.)
    .


ShiftExpression<out Expression shiftExpr> =
	(.Tuple2<Position,Operators.Shift> op=null;.)
    SimpleExpression<out shiftExpr>
    [ShiftOperator<out op> SimpleExpression<out Expression right> (.shiftExpr=new ShiftExpression(op._1,shiftExpr,op._2,right);.)]
    .

ShiftOperator<out Tuple2<Position,Operators.Shift> op> =
    (.
        Position pos=toPosition(la);
        Operators.Shift shiftOp=null;
    .)
    (
    sll  (.shiftOp=Operators.Shift.SLL;.)
    | srl (.shiftOp=Operators.Shift.SRL;.)
    | sla (.shiftOp=Operators.Shift.SLA;.)
    | sra (.shiftOp=Operators.Shift.SRA;.)
    | rol (.shiftOp=Operators.Shift.ROL;.)
    | ror (.shiftOp=Operators.Shift.ROR;.)
    )
    (.op=new Tuple2<Position,Operators.Shift>(pos,shiftOp);.)
    .

SimpleExpression<out Expression simpleExpr> =
    (.Tuple2<Position,Operators.Sign> sign=null;Tuple2<Position,Operators.Add> op=null;.)
    [Sign<out sign>] Term<out simpleExpr>
    (.if (sign!=null) simpleExpr=new SimpleExpression(sign._1,sign._2,simpleExpr);.)
    {AddingOperator<out op> Term<out Expression right> (.simpleExpr=new SimpleExpression(op._1,simpleExpr,op._2,right);.)}
    .

Sign<out Tuple2<Position,Operators.Sign> op> =
    (.
        Position pos=toPosition(la);
        Operators.Sign signOp=null;
    .)
    (
    plus (.signOp=Operators.Sign.PLUS;.)
    | minus (.signOp=Operators.Sign.MINUS;.)
    )
    (.op=new Tuple2<Position,Operators.Sign>(pos,signOp);.)
    .

AddingOperator<out Tuple2<Position,Operators.Add> op> =
    (.
        Position pos=toPosition(la);
        Operators.Add addOp=null;
    .)
    (
    plus (.addOp=Operators.Add.PLUS;.)
    | minus (.addOp=Operators.Add.MINUS;.)
    | ampersand (.addOp=Operators.Add.AMPERSAND;.)
    )
    (.op=new Tuple2<Position,Operators.Add>(pos,addOp);.)
    .

MultiplyingOperator<out Tuple2<Position,Operators.Term> op>=
    (.
        Position pos=toPosition(la);
        Operators.Term mulOp=null;
    .)
    (
    mul (.mulOp=Operators.Term.MUL;.)
    | div (.mulOp=Operators.Term.DIV;.)
    | mod (.mulOp=Operators.Term.MOD;.)
    | rem (.mulOp=Operators.Term.REM;.)
    )
    (.op=new Tuple2<Position,Operators.Term>(pos,mulOp);.)
    .

Term<out Expression term> =
    (.Tuple2<Position,Operators.Term> op=null;.)
    Factor<out term>
    {MultiplyingOperator<out op> Factor<out Expression right> (.term = new Term(op._1,term,op._2,right);.)}
    .

Factor<out Expression factor> =
	(.factor=null;.)
	(
	Primary<out factor> [doublestar (.Position pos=toPosition(t);.) Primary<out Expression right> (.factor = new Factor(pos,factor,Operators.Factor.POW,toOption(right));.)]
	| abs (.Position pos=toPosition(t);.) Primary<out Expression left> (.factor = new Factor(pos,left,Operators.Factor.ABS);.)
	| not (.Position pos=toPosition(t);.) Primary<out Expression left> (.factor = new Factor(pos,left,Operators.Factor.NOT);.)
	)
	.

Primary<out Expression expr> =
	(.expr=null;.)
	(
    IF(isQualifiedExpression()) SelectedName<out SelectedName typeName> QualifiedExpression<out expr,typeName>
    | Name<out Name name> (.expr=new NameExpression(name);.)
    | Literal<out expr>
    | Allocator<out expr>
    | Aggregate<out Aggregate aggregate> (.expr=new AggregateExpression(aggregate);.)
    )
    .

Allocator<out Expression newExpression> =
	(.Position pos=toPosition(la);newExpression=null;.)
	new SelectedName<out SelectedName selectedName>
	 	( QualifiedExpression<out Expression expr,selectedName> (.newExpression=new NewExpression(pos,new Left<Expression, SubTypeIndication>(expr));.)
	 	| [IndexConstraint<.out Seq<DiscreteRange> ranges.>
            (.
                Either<Range,Seq<DiscreteRange>> constraint=new Right<Range,Seq<DiscreteRange>>(ranges);
                newExpression=new NewExpression(pos,new Right<Expression, SubTypeIndication>(new SubTypeIndication(selectedName,toOption(constraint))));
            .)]
	 	)
	 	.

QualifiedExpression<out QualifiedExpression expr,SelectedName typeName> =
    apostrophe Aggregate<out Aggregate aggregate>
    (.expr=new QualifiedExpression(typeName,new AggregateExpression(aggregate));.)
    .

SelectedNameList<out Seq<SelectedName> list> =
    (.ListBuffer<SelectedName> tmpList=new ListBuffer<SelectedName>();.)
    SelectedName<out SelectedName name> (.tmpList.append(name);.) {comma SelectedName<out name> (.tmpList.append(name);.) }
    (.list=tmpList.toList();.)
    .

SelectedName<out SelectedName name> =
    (. ListBuffer<Identifier> parts=new ListBuffer<Identifier>();.)
    NamePrefix<out Identifier prefix> { NameSelectedPart<out Name.SelectedPart selectedPart> (.parts.append(selectedPart.identifier());.)}
    (.parts.prepend(prefix); name =new SelectedName(parts.toList());.)
    .

NameList<out Seq<Name> list> =
    (.ListBuffer<Name> tmpList=new ListBuffer<Name>();.)
    Name<out Name name> (.tmpList.append(name);.) {comma Name<out name> (.tmpList.append(name);.)}
    (.list=tmpList.toList();.)
    .

Name<out Name name> =
    (.ListBuffer<Name.Part> parts=new ListBuffer<Name.Part>();.)
    NamePrefix<out Identifier prefix> {NamePart<out Name.Part part> (.parts.append(part);.)}
    (.name =new Name(prefix,parts.toList());.)
    .

NamePrefix<out Identifier identifier> =
	(.identifier=null;.)
	(
 	Identifier<out identifier>
 	| stringLiteral (.identifier=toIdentifier(t);.)
 	)
 	.

NamePart<out at.jku.ssw.openvc.ast.Name.Part part> =
    (.part=null;.)
    (
    NameSelectedPart<out part>
    | NameAttributePart<out part>
    | IF(isNameSlicePart()) NameSlicePart<out part>
    | NameAssociationListPart<out part>
    )
    .

NameSelectedPart<out at.jku.ssw.openvc.ast.Name.SelectedPart part> =
    (.part=null;.)
    dot (
    Identifier<out Identifier identifier>(.part= new Name.SelectedPart(identifier);.)
    | characterLiteral (.part= new Name.SelectedPart(toIdentifier(t));.)
    | stringLiteral(.part= new Name.SelectedPart(toIdentifier(t));.)
    | all(.part= new Name.SelectedPart(toIdentifier(t));.)
    )
    .

NameAssociationListPart<out at.jku.ssw.openvc.ast.Name.AssociationListPart part> =
    lparen (.Position pos=toPosition(t);.) AssociationList<out AssociationList list> rparen (.part=new Name.AssociationListPart(pos,list);.)
    .

NameSlicePart<out at.jku.ssw.openvc.ast.Name.SlicePart part> =
    lparen DiscreteRange<out DiscreteRange discreteRange> rparen  (.part=new Name.SlicePart(discreteRange);.)
    .

NameAttributePart<out at.jku.ssw.openvc.ast.Name.AttributePart part> =
    (.Signature signature=null;Identifier identifier=null;Expression expr=null;.)
    [Signature<out signature>] apostrophe (Identifier<out identifier> | range (.identifier=toIdentifier(t);.)) [lparen Expression<out expr> rparen]
    (.part=new Name.AttributePart(toOption(signature),identifier,toOption(expr));.)
    .

Signature<out Signature signature> =
    (.Seq<SelectedName> list=null;SelectedName returnType=null;.)
    lbracket [SelectedNameList<out list>] [return TypeMark<out returnType>] rbracket
    (.signature =new Signature(toOption(list),toOption(returnType));.)
    .

Literal<out Expression literal> =
    (. LiteralType literalType=null;.)
    (
    realLiteral (.literalType=LiteralType.REAL_LITERAL;.)
    | integerLiteral (.literalType=LiteralType.INTEGER_LITERAL;.)
    | basedLiteral (.literalType=LiteralType.BASED_LITERAL;.)
    | characterLiteral (.literalType=LiteralType.CHARACTER_LITERAL;.)
    | bitStringLiteral (.literalType=LiteralType.BIT_STRING_LITERAL;.)
    | null (.literalType=LiteralType.NULL_LITERAL;.)
    )
    (.literal =new Literal(toPosition(t),t.val,literalType);.)
    [IF((t.kind==_integerLiteral || t.kind==_realLiteral) && (la.kind==_basicIdentifier || la.kind==_extendedIdentifier)) Identifier<out Identifier unit> (.literal = new PhysicalLiteral((Literal)literal,unit);.)]
    .

PhysicalLiteral<out PhysicalLiteral literal> =
    (.
        String text=la.val;
        LiteralType literalType=null;
        Position pos=toPosition(la);
    .)
    (
    integerLiteral (.literalType=LiteralType.INTEGER_LITERAL;.)
    | realLiteral (.literalType=LiteralType.REAL_LITERAL;.)
    )
    Identifier<out Identifier unit_name>
    (.literal =new PhysicalLiteral(pos,text,unit_name,literalType);.)
    .

ElementAssociation<out at.jku.ssw.openvc.ast.Aggregate.ElementAssociation element> =
    (.Choices choices=null;.)
    [IF(isChoiceInElementAssociation()) Choices<out choices> arrow] Expression<out Expression expr>
    (.element=new Aggregate.ElementAssociation(toOption(choices),expr);.)
    .

Aggregate<out Aggregate aggregate> =
    (. ListBuffer<Aggregate.ElementAssociation> elements=new ListBuffer<Aggregate.ElementAssociation>(); .)
    lparen (.Position pos=toPosition(t);.) ElementAssociation<out Aggregate.ElementAssociation element>(.elements.append(element);.) {comma ElementAssociation<out element> (.elements.append(element);.)} rparen
    (.aggregate =new Aggregate(pos,elements.toList());.)
    .

Choice<out at.jku.ssw.openvc.ast.Choices.Choice choice> =
    (.choice=null;.)
    (
    IF(isRangeInChoice()) DiscreteRange<out DiscreteRange range> (.Either<DiscreteRange, Expression> left=new Left<DiscreteRange, Expression>(range);choice =new Choices.Choice(toOption(left));.)
    | SimpleExpression<out Expression expr> (.Either<DiscreteRange, Expression> right=new Right<DiscreteRange, Expression>(expr);choice = new Choices.Choice(toOption(right));.)
    | others (.choice =new Choices.Choice();.)
    )
    .

Choices<out Choices choices> =
    (. ListBuffer<Choices.Choice> elements=new ListBuffer<Choices.Choice>(); .)
    Choice<out Choices.Choice choice> (.elements.append(choice);.) { bar Choice<out choice> (.elements.append(choice);.)}
    (.choices =new Choices(elements.toList());.)
    .

IdentifierList<out Seq<Identifier> list> =
    (.ListBuffer<Identifier> identifierList=new ListBuffer<Identifier>();.)
    Identifier<out Identifier identifier> (.identifierList.append(identifier);.) {comma Identifier<out identifier> (.identifierList.append(identifier);.) }
    (.list=identifierList.toList();.)
    .

UnusedIdentifier = Identifier<out Identifier unused>.

Identifier<out Identifier id> =
    (.id=null;.)
    (
    basicIdentifier (. id=toIdentifier(t);.)
    | extendedIdentifier (. id=toIdentifier(t,false);.)
    )
    .

LabelColon<out Identifier label> =
    Identifier<out label> colon
    .
		
END VHDL.
