import at.jku.ssw.openvc.ast.*;
import at.jku.ssw.openvc.ast.concurrentStatements.*;
import at.jku.ssw.openvc.ast.declarations.*;
import at.jku.ssw.openvc.ast.expressions.*;
import at.jku.ssw.openvc.ast.sequentialStatements.*;
import scala.Either;
import scala.Left;
import scala.Right;
import scala.Tuple2;
import scala.Option;
import scala.collection.Seq;
import scala.collection.mutable.ListBuffer;

COMPILER VHDL
  	public static class MyListBuffer<T> {
		private ListBuffer<T> impl=new ListBuffer<T>();
		public void append(T x){
			if (x!=null) impl.$plus$eq(x);
		}
		public void appendAll(Seq<T> x){
			if (x!=null) impl.appendAll(x);
		}
		public void prepend(T x){
			if (x!=null) impl.$plus$eq$colon(x);
		}
		public Seq<T> toList(){
			return impl.toList();
		}
		public boolean isEmpty(){
			return impl.isEmpty();
		}
	}
	
	private static <T> Option<T> toOption(T x){return Option.apply(x);}
	
	//group_template = GROUP identifier IS LPAREN ...
	//group_declaration = GROUP identifier COLON ...
	//la == GROUP
	private boolean IsGroupTemplate() {
		if (la.kind!=_GROUP) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_IS && next.kind!=_COLON && next.kind!=_SEMICOLON); 
		return next.kind==_IS;
	}

	//attribute_declaration = ATTRIBUTE identifier COLON type_mark SEMICOLON 
	//attribute_specification = ATTRIBUTE identifier OF entity_name_list COLON entity_class IS expression SEMICOLON 
	//la == ATTRIBUTE
	private boolean IsAttributeDeclaration() {
		if (la.kind!=_ATTRIBUTE) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_COLON && next.kind!=_OF && next.kind!=_SEMICOLON);
		return next.kind==_COLON;
	}

	//physical_type_definition = RANGE range UNITS ...
	//integer_or_floating_point_type_definition = RANGE range SEMICOLON
	//la == RANGE
	private boolean IsPhysicalType() {
		if (la.kind!=_RANGE) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_UNITS && next.kind!=_SEMICOLON);
		return next.kind==_UNITS;
	}

	//constrained array = LPAREN index_subtype_definition (COMMA index_subtype_definition)* RPAREN OF subtype_indication
	//index_subtype_definition = type_mark RANGE BOX
	//index_constraint = LPAREN discrete_range (COMMA  discrete_range)* RPAREN
	//la==LPAREN
	private boolean IsIndexSubtypeDefinition() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_BOX && next.kind!=_SEMICOLON && next.kind!=_RPAREN && next.kind!=_LPAREN);
		return next.kind==_BOX;
	}
	
	//procedure_call_statement = selected_name [LPAREN association_list RPAREN] SEMICOLON
	//signal_or_variable_assignment_statement = target (VAR_ASSIGN|LEQ) ....
	//target = name | aggregate
	private boolean IsAssignmentStatement() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_VAR_ASSIGN && next.kind!=_LEQ && next.kind!=_SEMICOLON);
		return next.kind==_VAR_ASSIGN || next.kind==_LEQ;
	}
	
	//concurrent_signal_assignment_statement = (target LEQ | WITH) ....
	//concurrent_procedure_call_statement = selected_name [LPAREN association_list RPAREN] SEMICOLON
	private boolean IsConcurrentSignalAssignmentStatement() {
		if (la.kind==_WITH) return true;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_LEQ && next.kind!=_SEMICOLON);
		return next.kind==_LEQ;
	}
	
	//
	//For those parameters with modes, the only modes that are allowed for formal parameters of a procedure are
	//in, inout, and out. If the mode is in and no object class is explicitly specified, constant is assumed. If the
	//mode is inout or out, and no object class is explicitly specified, variable is assumed.
	//
	//interface_constant_declaration = [CONSTANT] identifier_list COLON [IN] subtype_indication [VAR_ASSIGN expression] 
	private boolean IsInterfaceConstantDeclaration() {
		if (la.kind==_CONSTANT) return true;
		else if (la.kind==_VARIABLE || la.kind==_SIGNAL || la.kind==_FILE) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_VAR_ASSIGN && next.kind!=_SEMICOLON && next.kind!=_IN);
		return next.kind==_IN;
	}
	
	//interface_variable_declaration = [VARIABLE] identifier_list COLON [interface_mode] subtype_indication [VAR_ASSIGN expression]
	private boolean IsInterfaceVariableDeclaration() {
		if (la.kind==_VARIABLE) return true;
		else if (la.kind==_CONSTANT || la.kind==_SIGNAL || la.kind==_FILE) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_VAR_ASSIGN && next.kind!=_SEMICOLON && next.kind!=_IN && next.kind!=_INOUT && next.kind!=_OUT);
		return next.kind==_INOUT || next.kind==_OUT;
	}

	//search fo TO or DOWNTO in range: expression direction expression
	//choice = discrete_range
	//	| simple_expression
	//	| OTHERS		
	//choices = choice { BAR choice}
	//case_statement = .... {WHEN choices ARROW sequential_statement_list} ...
	//element_association = [choices ARROW] expression 
	//selected_waveform = waveform WHEN choices
	//selected_signal_assignment = ... selected_waveform {COMMA selected_waveform} SEMICOLON
	private boolean IsRangeInChoice() {
		if (la.kind==_OTHERS) return false;
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_BAR && next.kind!=_ARROW && next.kind!=_COMMA && next.kind!=_SEMICOLON && next.kind!=_TO_TOKEN && next.kind!=_DOWNTO);
		return next.kind==_TO_TOKEN || next.kind==_DOWNTO;
	}
	
	//search fo TO or DOWNTO in range = expression direction expression
	//block_configuration_index= 
	//	  discrete_range
	//	  |expression
	//block_specification=
	//	identifier [LPAREN block_configuration_index RPAREN]
	//	 | selected_name
	//block_configuration =
	//		FOR block_specification
	//		{use_clause}
	//		{
	//			blockConfiguration
	//			|component_configuration
	//		}
	//		END FOR SEMICOLON 
	private boolean IsDiscreteRangeInBlockConfigurationIndex() {
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_USE && next.kind!=_FOR && next.kind!=_END_TOKEN && next.kind!=_SEMICOLON && next.kind!=_TO_TOKEN && next.kind!=_DOWNTO);
		return next.kind==_TO_TOKEN || next.kind==_DOWNTO;
	}
	
		/*
		architecture_statement =
		(
		label_colon<out label> (
			architecture_statement_with_label<out concurrentStmt,label>
			| architecture_statement_optional_label<out concurrentStmt,label>
			)
		| architecture_statement_optional_label<out concurrentStmt,label>
		)
		.

		architecture_statement_with_label =
				(
				component_instantiation_statement
				| block_statement //starts with BLOCK
				| generate_statement  //starts with FOR|IF
				)
				.
						
		architecture_statement_optional_label<out ConcurrentStatement concurrentStmt, Identifier label> =
				[POSTPONED] 
				(process_statement //starts with PROCESS
				| concurrent_assertion_statement //starts with ASSERT
				| IF(IsConcurrentSignalAssignmentStatement())concurrent_signal_assignment_statement
				| concurrent_procedure_call_statement
				)
				
		component_instantiation_statement =
		(
		  [COMPONENT] selected_name
		  | ENTITY selected_name [LPAREN identifier RPAREN]
		  | CONFIGURATION selected_name
		)
		[generic_map_aspect]
		[port_map_aspect] SEMICOLON
	*/
	private boolean IsArchitecutreStatementWithLabel() {
		if (la.kind==_COMPONENT || la.kind==_ENTITY || la.kind==_CONFIGURATION  || la.kind==_BLOCK || la.kind==_FOR || la.kind==_IF_TOKEN) return true;
		else if (la.kind==_POSTPONED || la.kind==_PROCESS || la.kind==_ASSERT || la.kind==_FILE || IsConcurrentSignalAssignmentStatement()) return false;
		//untscheiden ob component_instantiation_statement oder concurrent_procedure_call_statement
		scanner.ResetPeek();
		Token next;
		do {
			next = scanner.Peek();
		}while (next.kind!=_GENERIC && next.kind!=_PORT && next.kind!=_SEMICOLON);
		return next.kind==_GENERIC || next.kind==_PORT;
	}	
	
	//name_slice_part = LPAREN discrete_range RPAREN.
	//name_indexed_part = LPAREN expression {COMMA expression}
	//name_association_list_part = LPAREN association_list RPAREN
	private boolean IsNameSlicePart() {
		if (la.kind!=_LPAREN) return false;
		scanner.ResetPeek();
		Token next;
		int count=1;//count LPAREN
		do {
			next = scanner.Peek();
			if (next.kind==_LPAREN) count++;
			else if (next.kind==_RPAREN) count--;
		}while (next.kind!=_BAR && next.kind!=_ARROW && next.kind!=_COMMA && next.kind!=_SEMICOLON && next.kind!=_TO_TOKEN && next.kind!=_DOWNTO);
		return next.kind==_TO_TOKEN || next.kind==_DOWNTO;
	}
		
	/*
	choice<out Choices.Choice choice> =
			IF(IsRangeInChoice())discrete_range
			| simple_expression
			| OTHERS
	choices = choice {BAR choice}.
	element_association = [IF(IsChoiceInElementAssociation()) choices ARROW] expression.
	aggregate = LPAREN  element_association {COMMA element_association} RPAREN .
	*/	
	private boolean IsChoiceInElementAssociation() {
		scanner.ResetPeek();
		Token next;
		int count=1;//count LPAREN
		do {
			next = scanner.Peek();
			if (next.kind==_LPAREN) count++;
			else if (next.kind==_RPAREN) count--;
		}while (count!=0 && next.kind!=_COMMA && next.kind!=_ARROW && next.kind!=_SEMICOLON && next.kind!=_OTHERS);
		return next.kind==_ARROW;
	}
	
	/*
	formal_part<out Name formal_part> = name<out formal_part> .	
	actual_part<out Option<Expression> actual_part> =  expression | OPEN .				
	association_element = [If(IsFormalPartInAssociationElement()) formal_part ARROW] actual_part .		
	association_list<out AssociationList list> = association_element {COMMA association_element}.
	LPAREN association_list RPAREN
	*/
	private boolean IsFormalPartInAssociationElement() {
		scanner.ResetPeek();
		Token next;
		int count=1;//count LPAREN
		do {
			next = scanner.Peek();
			if (next.kind==_LPAREN) count++;
			else if (next.kind==_RPAREN) count--;
		}while (count!=0 && next.kind!=_COMMA && next.kind!=_ARROW && next.kind!=_SEMICOLON && next.kind!=_OPEN);
		return next.kind==_ARROW;
	}
	
	private Position toPosition(Token token){
		return new Position(token.line,token.col);
	}    
	
	private Identifier toIdentifier(Token token){
		return toIdentifier(token,true);
	}

	private Identifier toIdentifier(Token token,boolean toLowerCase){
    	if (token.kind!=_STRING_LITERAL && token.kind!=_CHARACTER_LITERAL){
    		return new Identifier(toPosition(token),toLowerCase?token.val.toLowerCase():token.val.replace("\\\\","\\"));   
    	}else{
    		return new Identifier(toPosition(token),token.val);
    	}
	}      

IGNORECASE		
CHARACTERS
  	EOL 			= '\r' + '\n' .//+ '\u000C'.
  	
  	DIGIT = '0'..'9' .
  
  	//A B C D E F G H I J K L M N O P Q R S T U V W X Y Z À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï D . Ñ Ò Ó Ô Õ Ö Ø Ù Ú Û Ü ´ Y P '
  	UPPER_CASE_LETTER = 'A'..'Z' + '\u00c0'..'\u00d6' + '\u00d8' .. '\u00de'. //A - Z,À - Ö, Ø - Þ

  	//a b c d e f g h i j k l m n o p q r s t u v w x y z ß à á â ã ä å æ ç è é ê ë ì í î ï  ñ ò ó ô õ ö ø ù ú û ü ´ y ' p ÿ
  	LOWER_CASE_LETTER = 'a'..'z' + '\u00df'..'\u00f6' + '\u00f8'.. '\u00ff'. //a-z,ß - ö, ø - ÿ

  	SPECIAL_CHARACTER = '#' + '&' + '\'' + '(' + ')' + '*' + '+' + ',' + '-'
  		+ '.' + '/' + ':' + ';' + '<' + '=' + '>' + '[' + ']' + '_' + '|'.
    
  	SPACE_CHARACTER = ' ' + '\u00a0'. //space, non-breaking space

  	OTHER_SPECIAL_CHARACTER =  '!' + '$' + '%' + '@' + '?' + '^' + '`' + '{' + '}' + '~' 
		+ '\u00a1'..'\u00bf' + '\u00d7' + '\u00f7'.//  ¡ - ¿, × - ÷
	
  	LETTER = UPPER_CASE_LETTER + LOWER_CASE_LETTER.  
    
  	GRAPHIC_CHARACTER = 
  		UPPER_CASE_LETTER
  		+ DIGIT
  		+ SPECIAL_CHARACTER
  		+ SPACE_CHARACTER
  		+ LOWER_CASE_LETTER
  		+ OTHER_SPECIAL_CHARACTER
  		.
  
  	NEWLINE =  '\r' +'\n'.
  
  	LETTER_OR_DIGIT =  LETTER + DIGIT. 
  
  	EXTENDED_DIGIT = DIGIT + LETTER.
  
  	BASE_SPECIFIER = 'b' + 'o' + 'x'.
  
TOKENS
   
	BASIC_IDENTIFIER = LETTER { LETTER_OR_DIGIT | '_' }.
	
	//extended identifiers can't contain a single backslash
	EXTENDED_IDENTIFIER = "\\" { "\"" | "\\\\" | GRAPHIC_CHARACTER } "\\".
	   		 	
	BASED_LITERAL = DIGIT { ['_'] DIGIT } '#' EXTENDED_DIGIT { ['_'] EXTENDED_DIGIT } [ '.' EXTENDED_DIGIT { ['_'] EXTENDED_DIGIT } ] '#' ['e' [ '+' | '-' ] DIGIT { ['_'] DIGIT }].
	
	INTEGER_LITERAL = DIGIT { ['_'] DIGIT } ['e' [ '+' | '-' ] DIGIT { ['_'] DIGIT }].
	    
	REAL_LITERAL = DIGIT { ['_'] DIGIT }  '.' DIGIT { ['_'] DIGIT }  ['e' [ '+' | '-' ] DIGIT { ['_'] DIGIT }] .

	//string literals can't contain a single quotation mark
	STRING_LITERAL = "\"" { "\"\"" | "\\" | GRAPHIC_CHARACTER } "\"".
	  
	BIT_STRING_LITERAL = BASE_SPECIFIER '\"' [EXTENDED_DIGIT { ['_'] EXTENDED_DIGIT }] '\"'.
    
    CHARACTER_LITERAL = '\'' ("\"" | "\\" | GRAPHIC_CHARACTER ) '\'' CONTEXT (("\"" | "\\" | GRAPHIC_CHARACTER ) '\'').
    
    APOSTROPHE = '\'' .
	
	//BASED_INTEGER = EXTENDED_DIGIT { ['_'] EXTENDED_DIGIT }.
	
	//INTEGER = DIGIT { ['_'] DIGIT }.
	
	//EXPONENT = 'e' [ '+' | '-' ] INTEGER.
    
  	ABS="abs".
	ACCESS="access".
	AFTER="after".
	ALIAS="alias".
	ALL="all".
	AND="and".
	ARCHITECTURE="architecture".
	ARRAY="array".
	ASSERT="assert".
	ATTRIBUTE="attribute".
	BEGIN="begin".
	BLOCK="block".
	BODY="body".
	BUFFER="buffer".
	BUS="bus".
	CASE="case".
	COMPONENT="component".
	CONFIGURATION="configuration".
	CONSTANT="constant".
	DISCONNECT="disconnect".
	DOWNTO="downto".
	ELSE="else".
	ELSIF="elsif".
	END_TOKEN="end".
	ENTITY="entity".
	EXIT="exit".
	FILE="file".
	FOR="for".
	FUNCTION="function".
	GENERATE="generate".
	GENERIC="generic".
	GROUP="group".
	GUARDED="guarded".
	IF_TOKEN="if".
	IMPURE="impure".
	IN="in".
	INERTIAL="inertial".
	INOUT="inout".
	IS="is".
	LABEL="label".
	LIBRARY="library".
	LINKAGE="linkage".
	LITERAL="literal".
	LOOP="loop".
	MAP="map".
	MOD="mod".
	NAND="nand".
	NEW="new".
	NEXT="next".
	NOR="nor".
	NOT="not".
	NULL="null".
	OF="of".
	ON="on".
	OPEN="open".
	OR="or".
	OTHERS="others".
	OUT="out".
	PACKAGE="package".
	PORT="port".
	POSTPONED="postponed".
	PROCEDURE="procedure".
	PROCESS="process".
	PROTECTED="protected".
	PURE="pure".
	RANGE="range".
	RECORD="record".
	REGISTER="register".
	REJECT="reject".
	REM="rem".
	REPORT="report".
	RETURN="return".
	ROL="rol".
	ROR="ror".
	SELECT="select".
	SEVERITY="severity".
	SHARED="shared".
	SIGNAL="signal".
	SLA="sla".
	SLL="sll".
	SRA="sra".
	SRL="srl".
	SUBTYPE="subtype".
	THEN="then".
	TO_TOKEN="to".
	TRANSPORT="transport".
	TYPE="type".
	UNAFFECTED="unaffected".
	UNITS="units".
	UNTIL="until".
	USE="use".
	VARIABLE="variable".
	WAIT="wait".
	WHEN="when".
	WHILE="while".
	WITH="with".
	XNOR="xnor".
	XOR="xor".
  		
  	DOUBLESTAR    = "**".
  	LEQ           = "<=".
  	GEQ           = ">=".
  	ARROW         = "=>".
  	NEQ           = "/=".
  	VAR_ASSIGN    = ":=".
  	BOX           = "<>".
  	SEMICOLON     = ";".
  	COMMA         = ",".
  	AMPERSAND     = "&".
  	LPAREN        = "(".
  	RPAREN        = ")".
  	LBRACKET      = "[".
  	RBRACKET      = "]".
  	COLON         = ":".
  	MUL           = "*".
  	DIV           = "/".
  	PLUS          = "+".
  	MINUS         = "-".
  	LT            = "<".
 	GT            = ">".
  	EQ            = "=".
  	BAR           = "|".
  	DOT           = ".".

COMMENTS FROM "/*" TO "*/" NESTED
//A comment can appear on any line of a VHDL description and may contain any character except the format effectors vertical tab, carriage return, line feed, and form feed.
COMMENTS FROM "--" TO '\u000a' //line feed
IGNORE '\t' + ' ' + NEWLINE

PRODUCTIONS

VHDL<out DesignFile designFile> =	
		(.
		  MyListBuffer<DesignUnit> units=new MyListBuffer<DesignUnit>(); 		
		  la = new Token();
		  la.val = "";		
		  Get();
		.)
		design_unit<out DesignUnit designUnit> (. units.append(designUnit); .)
		{design_unit<out designUnit> (. units.append(designUnit); .) }
		(.
		  designFile=new DesignFile(units.toList());
		  Expect(0);
		.)
		.

design_unit<out DesignUnit designUnit> =
		(.
			MyListBuffer<Identifier> libraries=new MyListBuffer<Identifier>();
			MyListBuffer<UseClause> useClauses=new MyListBuffer<UseClause>();
		.)
		{
		library_clause<.out Seq<Identifier> identifierList.> (.libraries.appendAll(identifierList);.)
		|use_clause<out UseClause useClause> (.useClauses.append(useClause);.)
		} (.Position pos=toPosition(la);.) library_unit<out LibraryUnit libraryUnit>
		(.designUnit=new DesignUnit(pos,libraries.toList(),useClauses.toList(),toOption(libraryUnit));.)
		.

library_unit<out LibraryUnit libraryUnit> =
		(.libraryUnit=null;.)
		(
		entity_declaration<out libraryUnit>
		| architecture_body<out libraryUnit> 
		| IF(scanner.Peek().kind==_BODY)package_body<out libraryUnit>
		| package_declaration<out libraryUnit> 
		| configuration_declaration<out libraryUnit> 
		)
		.	
		
library_clause<out Seq<Identifier> identifierList> =
	LIBRARY identifier_list<out identifierList> SEMICOLON 
	.

generic_clause<out InterfaceList genericList> =
	   GENERIC LPAREN generic_interface_list<out genericList> RPAREN SEMICOLON
	   .

generic_interface_list<out InterfaceList list> =
	(. MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    interface_constant_declaration<out InterfaceList.InterfaceConstantDeclaration declaration> (.elements.append(declaration);.) { SEMICOLON interface_constant_declaration<out declaration> (.elements.append(declaration); .)}
    (. list=new InterfaceList(elements.toList());.)
    .
    
port_clause<out InterfaceList portList> =
	 PORT LPAREN port_interface_list<out portList> RPAREN SEMICOLON
	 .

port_interface_list<out InterfaceList list> =
	(. MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    interface_signal_declaration_procedure<out InterfaceList.InterfaceSignalDeclaration declaration> (.elements.append(declaration); .) { SEMICOLON interface_signal_declaration_procedure<out declaration> (.elements.append(declaration);.)}
    (.list=new InterfaceList(elements.toList());.)
    .
	
entity_declaration<out EntityDeclaration entityDecl> =
		(.
		 	MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();
		 	MyListBuffer<ConcurrentStatement> concurrentStmts=new MyListBuffer<ConcurrentStatement>();
		 	InterfaceList genericClause=null,portClause=null;
		 	ConcurrentStatement stmt=null;
		 	Identifier label=null;
		 	boolean postponed=false;
		.)
		ENTITY identifier<out Identifier start_identifier> IS
			[generic_clause<out genericClause>]
			[port_clause<out portClause>]
			{entity_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item); .)} 
		[BEGIN
			{[IF(scanner.Peek().kind==_COLON) label_colon<out label>] [POSTPONED (.postponed=true;.)] 
			(
			concurrent_assertion_statement<out stmt,label,postponed>
			| concurrent_procedure_call_statement<out stmt,label,postponed>
			| process_statement<out stmt,label,postponed>
			)
			(.concurrentStmts.append(stmt);.)
			}]
		END_TOKEN [ENTITY] [unused_identifier] SEMICOLON
		(.entityDecl=new EntityDeclaration(start_identifier,toOption(genericClause),toOption(portClause),declarativeItems.toList(),concurrentStmts.toList());.)
		.

entity_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| disconnection_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.
		
architecture_body<out ArchitectureDeclaration archDecl> =
		(.MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		ARCHITECTURE identifier<out Identifier start_identifier> OF selected_name<out SelectedName entityName> IS
			{block_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item); .)}
		BEGIN
			architecture_statement_list<.out Seq<ConcurrentStatement> statementList.>
		END_TOKEN [ARCHITECTURE] [unused_identifier] SEMICOLON
		(.archDecl=new ArchitectureDeclaration(start_identifier,declarativeItems.toList(),entityName,statementList); .)
		.
		
configuration_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		 use_clause<out item> 
		| group_declaration<out item> 
		| attribute_specification<out item>
		)
		.
		
configuration_declaration<out ConfigurationDeclaration configDecl> =
		(.MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		CONFIGURATION identifier<out Identifier start_identifier> OF selected_name<out SelectedName entityName> IS
			{configuration_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
			block_configuration<out BlockConfiguration blockConfig>
		END_TOKEN [CONFIGURATION] [unused_identifier] SEMICOLON
		(.configDecl=new ConfigurationDeclaration(start_identifier,declarativeItems.toList(),entityName,blockConfig);.)
		.

block_configuration_index<out Either<DiscreteRange,Expression> index> =
		  (.index=null;.)
		  (
		  IF(IsDiscreteRangeInBlockConfigurationIndex())discrete_range<out DiscreteRange discreteRange> (.index=new Left<DiscreteRange,Expression>(discreteRange);.)
		  |expression<out Expression expr> (.index=new Right<DiscreteRange,Expression>(expr);.)
		  )
		  .

block_specification<out BlockConfigurationSpecification blockSpec>  = 
		//could be a block_statement_label or generate_statement_label
		(.blockSpec=null;Either<DiscreteRange,Expression> blockIndex=null;.)
		(
		  IF(scanner.Peek().kind==_LPAREN) identifier<out Identifier identifier> [LPAREN block_configuration_index<out blockIndex> RPAREN]
			(.blockSpec=new BlockConfigurationSpecification(new Right<SelectedName, Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>>(new Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>(identifier,toOption(blockIndex))));.)
		 | selected_name<out SelectedName selectedName> (.blockSpec=new BlockConfigurationSpecification(new Left<SelectedName, Tuple2<Identifier, Option<Either<DiscreteRange, Expression>>>>(selectedName));.)
		)
		.
	 	 
block_configuration<out BlockConfiguration blockConfig> =
		(.
			MyListBuffer<UseClause> useClauses=new MyListBuffer<UseClause>();
			MyListBuffer<Object> configurations=new MyListBuffer<Object>();
		.)
		FOR block_specification<out BlockConfigurationSpecification blockSpec>
		{use_clause<out UseClause useClause> (.useClauses.append(useClause);.)}
		{
			block_configuration<out BlockConfiguration blockConfiguration> (.configurations.append(blockConfiguration);.)
			|component_configuration<out ComponentConfiguration componentConfiguration> (.configurations.append(componentConfiguration);.)
		}
		END_TOKEN FOR SEMICOLON 
		(.blockConfig=new BlockConfiguration(blockSpec,useClauses.toList(),configurations.toList());.)
		.
		
component_configuration<out ComponentConfiguration componentConfig> =
		(.BlockConfiguration blockConfiguration=null;Object indication=null;.)
		FOR component_specification<out Object componentSpec>
			[binding_indication<out indication> SEMICOLON]
			[block_configuration<out blockConfiguration>]
		END_TOKEN FOR SEMICOLON
		(.componentConfig=new ComponentConfiguration(componentSpec,toOption(indication),toOption(blockConfiguration));.) 
		.	
			
package_declaration<out PackageDeclaration packageDecl> = 
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); .)
		PACKAGE identifier<out Identifier start_identifier> IS
			{package_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
		END_TOKEN [PACKAGE] [unused_identifier] SEMICOLON
		(.packageDecl=new PackageDeclaration(start_identifier,declarativeItems.toList());.)
		.
		
package_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| component_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| disconnection_specification<out item> 
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.

package_body<out PackageBodyDeclaration packageBody> =
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		PACKAGE BODY identifier<out Identifier start_identifier> IS
			{package_body_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
		END_TOKEN [PACKAGE BODY] [unused_identifier] SEMICOLON
		(.packageBody = new PackageBodyDeclaration(start_identifier,declarativeItems.toList());.)
		.
    
package_body_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| use_clause<out item>
		| attribute_specification<out item> //attribute_specification is not part of VHDL 2002, added to compile ghdl math_real-body.vhd
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item> 
		)
		.
		
designator<out Identifier identifier> =
	  (.identifier = null;.)
	  (
	  identifier<out identifier>
	  | STRING_LITERAL (.identifier=toIdentifier(t);.) //STRING_LITERAL is a operator symbol
	  )
	  .
	  
subprogram_specification<out SubProgramDeclaration decl> =
	  (.Position pos=toPosition(la);Identifier designator=null;InterfaceList list=null;decl=null;.)
	  (
		PROCEDURE designator<out designator> [LPAREN parameter_interface_list_procedure<out list> RPAREN] 
		(.decl=new ProcedureDeclaration(pos,designator,toOption(list));.)
		| (.boolean pure=true;.)[PURE | IMPURE(.pure=false;.)] FUNCTION designator<out designator> [LPAREN parameter_interface_list_function<out list> RPAREN] RETURN type_mark<out SelectedName returnType>
		(.decl=new FunctionDeclaration(pos,pure,designator,toOption(list),returnType);.)
	  )
	  .	

subprogram_declaration_or_body<out DeclarativeItem declOrBody> =
		(.SubProgramDefinition subProgramDef=null;.)
		subprogram_specification<out SubProgramDeclaration decl> [subprogram_body<out subProgramDef,decl>] SEMICOLON
		(. if (subProgramDef!=null) declOrBody=subProgramDef; else declOrBody=decl;.)	
		.
		
subprogram_declaration<out DeclarativeItem subprogramDecl> =
	subprogram_specification<out subprogramDecl> SEMICOLON
	.
	
subprogram_body<out SubProgramDefinition subProgramDef,SubProgramDeclaration subprogramDecl> =
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); .)
		IS
			{subprogram_declarative_item<out DeclarativeItem item>(. declarativeItems.append(item); .)} 
		BEGIN
			sequential_statement_list<.out Seq<SequentialStatement> sequentialStatements.>
		END_TOKEN [PROCEDURE | FUNCTION] [designator<out Identifier unused>]
		(.			
			if (subprogramDecl instanceof ProcedureDeclaration){
				ProcedureDeclaration procDecl = (ProcedureDeclaration)subprogramDecl;
				subProgramDef=new ProcedureDefinition(subprogramDecl.position(),procDecl.identifier(),procDecl.parameterInterfaceList(),declarativeItems.toList(),sequentialStatements);
			}else {
				FunctionDeclaration funcDecl=(FunctionDeclaration)subprogramDecl;
				subProgramDef=new FunctionDefinition(subprogramDecl.position(),funcDecl.pure(),funcDecl.identifier(),funcDecl.parameterInterfaceList(),funcDecl.returnType(),declarativeItems.toList(),sequentialStatements);
			}
		.)
		.
		
subprogram_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| use_clause<out item> 
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		) 
		.

type_declaration<out AbstractTypeDeclaration typeDecl> =
		(.Position pos=toPosition(la);typeDecl=null;.)
		TYPE identifier<out Identifier id> (
		IS type_definition<out typeDecl,id,pos> SEMICOLON
		| SEMICOLON (.typeDecl=new IncompleteTypeDeclaration(pos,id);.) 
		)
		.

type_definition<out AbstractTypeDeclaration typeDef,Identifier id,Position pos> =
		(.typeDef=null;.)
		(
		enumeration_type_definition<out typeDef,id,pos> 
		| IF(IsPhysicalType()) physical_type_definition<out typeDef,id,pos>
		| integer_or_floating_point_type_definition<out typeDef,id,pos>
		| array_type_definition<out typeDef,id,pos>
		| record_type_definition<out typeDef,id,pos>
		| access_type_definition<out typeDef,id,pos> 
		| file_type_definition<out typeDef,id,pos>
		| IF(la.kind==_PROTECTED && scanner.Peek().kind==_BODY)protected_type_body<out typeDef,id,pos> 
		| protected_type_declaration<out typeDef,id,pos>
		)
		.

	
constant_declaration <out ConstantDeclaration constantDecl> =
		(.Position pos=toPosition(la);Expression expr=null;.)
		CONSTANT identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] SEMICOLON 
		(.constantDecl=new ConstantDeclaration(pos,list,subType,toOption(expr));.)
		.
	
signal_declaration<out SignalDeclaration signalDecl> =
		(.Position pos=toPosition(la);Expression expr=null;boolean reg=false,bus=false;.)
		SIGNAL identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType> [REGISTER(.reg=true;.)|BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>] SEMICOLON
		(.
			SignalType signalType=null;
				if(reg) signalType=SignalType.REGISTER;
				else if (bus) signalType=SignalType.BUS;
			signalDecl=new SignalDeclaration(pos,list,subType,toOption(signalType),toOption(expr));
		.)
		.
		
variable_declaration<out VariableDeclaration varDecl> =
		(.Position pos=toPosition(la);Expression expr=null;boolean shared=false;.)
		[SHARED(.shared=true;.)] VARIABLE identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] SEMICOLON
		(.varDecl=new VariableDeclaration(pos,shared,list,subType,toOption(expr));.)
		.
	
file_declaration<out FileDeclaration fileDecl> =
		(.Position pos=toPosition(la);Expression file_open_kind_expression=null,file_logical_name=null;.)
		FILE identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType> [[OPEN expression<out file_open_kind_expression>] IS expression<out file_logical_name>] SEMICOLON
		(.fileDecl=new FileDeclaration(pos,list,subType,toOption(file_open_kind_expression),toOption(file_logical_name));.)
		.
	
alias_declaration<out AliasDeclaration aliasDecl> =
		(.Position pos=toPosition(la);Signature signature=null;SubTypeIndication subType=null;.)
		ALIAS alias_designator<out Identifier designator> [COLON subtype_indication<out subType>] IS name<out Name name> [signature<out signature>] SEMICOLON
		(.aliasDecl=new AliasDeclaration(pos,designator,toOption(subType),name,toOption(signature));.)
		.

alias_designator<out Identifier identifier> =
		(.identifier=null;.)
		(identifier<out identifier> 
		|CHARACTER_LITERAL(.identifier=toIdentifier(t);.)
		|STRING_LITERAL(.identifier=toIdentifier(t);.)
		).	
	
component_declaration<out ComponentDeclaration componentDecl> =
		(.Position pos=toPosition(la);InterfaceList genericClause=null,portClause=null;.)
		COMPONENT identifier<out Identifier start_identifier> [IS]
			[generic_clause<out genericClause>]
			[port_clause<out portClause>]
		END_TOKEN COMPONENT [unused_identifier] SEMICOLON
		(.componentDecl=new ComponentDeclaration(pos,start_identifier,toOption(genericClause),toOption(portClause));.)
		.

attribute_declaration<out AttributeDeclaration attributeDecl> =
		(.Position pos=toPosition(la);.)
		ATTRIBUTE identifier<out Identifier identifier> COLON type_mark<out SelectedName type> SEMICOLON 
		(.attributeDecl=new AttributeDeclaration(pos,identifier,type);.)
		.
	
attribute_specification<out AttributeSpecification node> =
		(.Position pos=toPosition(la);Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> nameList=null;.)
		ATTRIBUTE identifier<out Identifier identifier> OF entity_name_list<out nameList> COLON entity_class<out EntityClass entityClass> IS expression<out Expression expr> SEMICOLON 
		(.node=new AttributeSpecification(pos,identifier,nameList,entityClass,expr);.)
		.
		
entity_designator<out Tuple2<Identifier,Option<Signature>> designator> =
		(. Identifier identifier=null; Signature signature=null;.)
		(identifier<out identifier>
		|CHARACTER_LITERAL(.identifier=toIdentifier(t);.)
		|STRING_LITERAL(.identifier=toIdentifier(t);.)
		) [signature<out signature>]
		(.designator=new Tuple2<Identifier,Option<Signature>>(identifier,toOption(signature)); .)
		.
	
entity_name_list<out Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> list> =
		(. 
		   MyListBuffer<Tuple2<Identifier,Option<Signature>>> elements=new MyListBuffer<Tuple2<Identifier,Option<Signature>>>();
		   Tuple2<Identifier,Option<Signature>> designator=null;
		   list=null;
		.)
		(
		entity_designator<out designator> (.elements.append(designator); .) {COMMA entity_designator<out designator> (.elements.append(designator);.)} 
		(.list=new Left<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(elements.toList());.)
		| OTHERS (.list=new Right<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(toIdentifier(t));.)
		| ALL (.list=new Right<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier>(toIdentifier(t));.)
		)
		.

entity_class<out EntityClass entityClass> =
		(.entityClass=null;.)
		(
		ENTITY (.entityClass=EntityClass.ENTITY;.)
		| ARCHITECTURE (.entityClass=EntityClass.ARCHITECTURE;.)
		| CONFIGURATION (.entityClass=EntityClass.CONFIGURATION;.)
		| PACKAGE (.entityClass=EntityClass.PACKAGE;.)
		| PROCEDURE (.entityClass=EntityClass.PROCEDURE;.)
		| FUNCTION (.entityClass=EntityClass.FUNCTION;.)
		| TYPE (.entityClass=EntityClass.TYPE;.)
		| SUBTYPE (.entityClass=EntityClass.SUBTYPE;.)
		| CONSTANT (.entityClass=EntityClass.CONSTANT;.)
		| SIGNAL (.entityClass=EntityClass.SIGNAL;.)
		| VARIABLE (.entityClass=EntityClass.VARIABLE;.)
		| FILE (.entityClass=EntityClass.FILE;.)
		| COMPONENT (.entityClass=EntityClass.COMPONENT;.)
		| LABEL (.entityClass=EntityClass.LABEL;.)
		| LITERAL (.entityClass=EntityClass.LITERAL;.)
		| UNITS (.entityClass=EntityClass.UNITS;.)
		| GROUP (.entityClass=EntityClass.GROUP;.)
		)
		.
		
configuration_specification<out ConfigurationSpecification configSpec> =
		(.Position pos=toPosition(la);.)
		FOR component_specification<out Object componentSpec>
			binding_indication<out Object indication> SEMICOLON
		(.configSpec= new ConfigurationSpecification(pos);.)
		.
		
instantiation_list<out Either<Seq<Identifier>,Identifier> list> =
	  (.list=null;.)
	  (
	  identifier_list<.out Seq<Identifier> identifierList.> (.list=new Left<Seq<Identifier>,Identifier>(identifierList);.)
		| OTHERS (.list=new Right<Seq<Identifier>,Identifier>(toIdentifier(t));.)
		| ALL (.list=new Right<Seq<Identifier>,Identifier>(toIdentifier(t));.)
	  )
	  .		

component_specification<out Object spec> = 
		instantiation_list<out Object list> COLON selected_name<out SelectedName name>
		(.spec=null;.)
		.

entity_aspect =
		ENTITY selected_name<out SelectedName entity_name> [LPAREN identifier<out Identifier architecture_identifier> RPAREN] 
		| CONFIGURATION  selected_name<out SelectedName configuration_name> 
		| OPEN 
		.
		
binding_indication<out Object indication> =
		[USE entity_aspect]
		[generic_map_aspect<out AssociationList genericMap>]
		[port_map_aspect<out AssociationList portMap>]
		(.indication=null;.)
		.

disconnection_specification<out DisconnectionSpecification disconnectSpec> =
		(.Position pos=toPosition(la);Identifier id=null;Seq<SelectedName> list=null;.)
		DISCONNECT (selected_name_list<out list> | OTHERS(.id=toIdentifier(t);.) | ALL (.id=toIdentifier(t);.)) COLON type_mark<out SelectedName type> AFTER expression<out Expression expr> SEMICOLON
		(.disconnectSpec= new DisconnectionSpecification(pos,id==null?new Left<Seq<SelectedName>,Identifier>(list):new Right<Seq<SelectedName>,Identifier>(id),type,expr);.)
		.

entity_class_entry<out GroupTemplateDeclaration.Element entry> =
		(.boolean box=false;.)
	  	entity_class<out EntityClass  entityClass> [BOX(.box=true;.)]
		(.entry = new GroupTemplateDeclaration.Element(entityClass,box);.)
		.
		
group_template_declaration<out GroupTemplateDeclaration groupTemplateDecl> =
		(.
		  Position pos=toPosition(la);
		  MyListBuffer<GroupTemplateDeclaration.Element> elements=new MyListBuffer<GroupTemplateDeclaration.Element>(); 
	    .)
		GROUP identifier<out Identifier identifier> IS LPAREN entity_class_entry<out GroupTemplateDeclaration.Element entry> (.elements.append(entry);.) {COMMA entity_class_entry<out entry> (.elements.append(entry);.)}  RPAREN SEMICOLON
		(.groupTemplateDecl=new GroupTemplateDeclaration(pos,identifier,elements.toList());.)
		.
		
		
group_declaration<out GroupDeclaration groupDecl> =
		(.Position pos=toPosition(la);Seq<Either<Name,Identifier>> list=null;.)		
		GROUP identifier<out Identifier identifier> COLON selected_name<out SelectedName selectedName> LPAREN group_constituent_list<out list> RPAREN SEMICOLON
		(.groupDecl=new GroupDeclaration(pos,identifier,selectedName,list);.)
		.
	
group_constituent<out Either<Name,Identifier> constituent> =
	(.constituent=null;.)
	(
       name<out Name name> (.constituent=new Left<Name,Identifier>(name);.)
    |  CHARACTER_LITERAL (.constituent=new Right<Name,Identifier>(toIdentifier(t));.)
    )
    .

group_constituent_list<out Seq<Either<Name,Identifier>> list> =
		(. 
		   MyListBuffer<Either<Name,Identifier>> elements=new MyListBuffer<Either<Name,Identifier>>(); 
		   Either<Name,Identifier> element=null;
		.)
		group_constituent<out element> (.elements.append(element); .) {COMMA group_constituent<out element> (.elements.append(element);.)}
		(.list=elements.toList();.)
    	.
    
use_clause<out UseClause useClause> =
		(.Position pos=toPosition(la);.)
		USE selected_name_list<.out Seq<SelectedName> list.> SEMICOLON
		(.useClause=new UseClause(pos,list);.)
		.

enumeration_literal<out Identifier identifier> =
		(.identifier=null;.)
		(
		identifier<out identifier>
		|CHARACTER_LITERAL (.identifier=toIdentifier(t);.)
		)
		.
	
enumeration_type_definition<out EnumerationTypeDefinition enumTypeDef,Identifier id,Position pos> =
		(. 
		   MyListBuffer<Identifier> elements=new MyListBuffer<Identifier>(); 
		   Identifier element=null;
		.)
		LPAREN enumeration_literal<out element> (.elements.append(element);.){COMMA enumeration_literal<out element> (.elements.append(element);.)} RPAREN
		(.enumTypeDef=new EnumerationTypeDefinition(pos,id,elements.toList());.)
		.
	
integer_or_floating_point_type_definition<out IntegerOrFloatingPointTypeDefinition intOrFloat,Identifier id,Position pos> =
		RANGE range<out Range range>
		(.intOrFloat=new IntegerOrFloatingPointTypeDefinition(pos,id,range);.)
		.
			
physical_type_definition<out PhysicalTypeDefinition physicalTypeDef, Identifier id,Position pos> =
		(. MyListBuffer<PhysicalTypeDefinition.Element> elements=new MyListBuffer<PhysicalTypeDefinition.Element>(); .)
		RANGE range<out Range range>
		UNITS
			identifier<out Identifier baseIdentifier> SEMICOLON
			{
			identifier<out Identifier identifier> EQ physical_literal<out PhysicalLiteral literal> SEMICOLON 
			(.elements.append(new PhysicalTypeDefinition.Element(identifier,literal));.)
			}
		END_TOKEN UNITS [unused_identifier]
		(.physicalTypeDef=new PhysicalTypeDefinition(pos,id,range,baseIdentifier,elements.toList());.)
		.		

index_subtype_definition<out SelectedName typeMark> =
	 	type_mark<out typeMark> RANGE BOX
		.
				
array_type_definition<out AbstractArrayTypeDefinition arrayTypeDef,Identifier id,Position pos> = 
		(. MyListBuffer<SelectedName> unConstraintList=new MyListBuffer<SelectedName>();
		   SubTypeIndication subType=null;
		   Seq<DiscreteRange> ranges =null;
		   SelectedName type=null;
		.)
		ARRAY (
		IF(IsIndexSubtypeDefinition()) LPAREN index_subtype_definition<out type> (.unConstraintList.append(type);.) {COMMA index_subtype_definition<out type> (.unConstraintList.append(type);.)} RPAREN OF subtype_indication<out subType>
		| index_constraint<out ranges> OF subtype_indication<out subType>
		)
		(.
			if (unConstraintList.isEmpty()) arrayTypeDef=new ConstrainedArrayTypeDefinition(pos,id,ranges,subType);
			else arrayTypeDef=new UnconstrainedArrayTypeDefinition(pos,id,unConstraintList.toList(),subType);
		.)
		.
		
record_type_definition<out RecordTypeDefinition recordTypeDef,Identifier id,Position pos> =
		(. MyListBuffer<RecordTypeDefinition.Element> elements=new MyListBuffer<RecordTypeDefinition.Element>(); .)
		RECORD
			identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType> SEMICOLON
			(.elements.append(new RecordTypeDefinition.Element(list, subType));.) 
			{
			identifier_list<.out list.> COLON subtype_indication<out subType> SEMICOLON
			(.elements.append(new RecordTypeDefinition.Element(list, subType));.)
			}
		END_TOKEN RECORD [unused_identifier]
		(.recordTypeDef=new RecordTypeDefinition(pos,id,elements.toList());.)
		.

access_type_definition<out AccessTypeDefinition accessTypeDef,Identifier id,Position pos> =
		ACCESS subtype_indication<out SubTypeIndication subType> 
		(.accessTypeDef=new AccessTypeDefinition(pos,id,subType);.)
		.
	
file_type_definition<out FileTypeDefinition fileTypeDef,Identifier id,Position pos> =
		FILE OF type_mark<out SelectedName type> 
		(.fileTypeDef=new FileTypeDefinition(pos,id,type);.)
		.
		
protected_type_declaration<out ProtectedTypeDeclaration protectedTypeDecl,Identifier id,Position pos> =
		(. MyListBuffer<DeclarativeItem> items=new MyListBuffer<DeclarativeItem>(); .)
		PROTECTED
			{protected_type_declarative_item<out DeclarativeItem item>(.items.append(item);.)}
		END_TOKEN PROTECTED [unused_identifier]
		(.protectedTypeDecl=new ProtectedTypeDeclaration(pos,id,items.toList());.)
		.
				
protected_type_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration<out item>
		| attribute_specification<out item> 
		| use_clause<out item>
		)
		.

protected_type_body<out ProtectedTypeBodyDeclaration protectedTypeBody,Identifier id,Position pos> =
		(. MyListBuffer<DeclarativeItem> items=new MyListBuffer<DeclarativeItem>(); .)
		PROTECTED BODY
			{protected_type_body_declarative_item<out DeclarativeItem item>(.items.append(item);.)}
		END_TOKEN PROTECTED BODY [unused_identifier]
		(.protectedTypeBody=new ProtectedTypeBodyDeclaration(pos,id,items.toList());.)
		.

protected_type_body_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item> 
		)
		.
		
subtype_declaration<out SubTypeDeclaration subTypeDecl> =
		(.Position pos=toPosition(la);.)
		SUBTYPE identifier<out Identifier identifier> IS subtype_indication<out SubTypeIndication subType> SEMICOLON
		(.subTypeDecl=new SubTypeDeclaration(pos,identifier,subType);.)
		.
		
subtype_indication<out SubTypeIndication subType> =
		(.Either<Range,Seq<DiscreteRange>> constraint=null;SelectedName n2=null;.)
		selected_name<out SelectedName n1> [selected_name<out n2>] [constraint<out constraint>]
		(.
			if (n2!=null) subType=new SubTypeIndication(toOption(n1),n2,toOption(constraint));
			else subType=new SubTypeIndication(n1,toOption(constraint));
		.)
		.
  
direction<out Direction rangeDirection> =
		(.rangeDirection=null;.)
		(
		TO_TOKEN (.rangeDirection=Direction.To;.)
		|DOWNTO (.rangeDirection=Direction.Downto;.)
		)
		.

range_constraint<out Range rangeContraint> =
		RANGE range<out rangeContraint>
		.

index_constraint<out Seq<DiscreteRange> ranges> =
		(. 
		   MyListBuffer<DiscreteRange> list=new MyListBuffer<DiscreteRange>();
		   DiscreteRange discreteRange=null;
		.)
		LPAREN discrete_range<out discreteRange> (.list.append(discreteRange);.) {COMMA  discrete_range<out discreteRange> (.list.append(discreteRange);.)} RPAREN
		(.ranges = list.toList();.)
		.
		
range<out Range range> =
		(
		simple_expression<out Expression from> direction<out Direction rangeDirection>  simple_expression<out Expression to>
		//TODO| name
		)
		(.range =new Range(from,rangeDirection,to);.)
		.

constraint<out Either<Range,Seq<DiscreteRange>> constraint> =
		(.constraint=null;.)
		(
		range_constraint<out Range rangeContraint> (.constraint = new Left<Range,Seq<DiscreteRange>>(rangeContraint);.)
		| index_constraint<.out Seq<DiscreteRange> ranges.> (.constraint = new Right<Range,Seq<DiscreteRange>>(ranges);.)
		)
		.

discrete_range<out DiscreteRange discreteRange> =
		//TODO(simple_expression direction)=>r=range {$discreteRange=new DiscreteRange(new Left($r.range_))}
		//|(selected_name range_constraint)=>discrete_subtype_indication=subtype_indication {$discreteRange=new DiscreteRange(new Right($discrete_subtype_indication.subType))}
		 range<out Range range> (.discreteRange=new DiscreteRange(new Left<Range, SubTypeIndication>(range));.)
		.
		
type_mark<out SelectedName typeName> =
		selected_name<out typeName> // could be type_name or subtype_name;
		.
		
architecture_statement_list<out Seq<ConcurrentStatement> list> =
	  (.MyListBuffer<ConcurrentStatement> statementList=new MyListBuffer<ConcurrentStatement>();.)
	  {architecture_statement<out ConcurrentStatement stmt> (.statementList.append(stmt);.)}
	  (.list=statementList.toList();.)
	  .

architecture_statement<out ConcurrentStatement concurrentStmt> =
		(.concurrentStmt=null; Identifier label=null;.)
		(
		IF(scanner.Peek().kind==_COLON) label_colon<out label> (
			IF(IsArchitecutreStatementWithLabel()) architecture_statement_with_label<out concurrentStmt,label>
			| architecture_statement_optional_label<out concurrentStmt,label>
			)
		| architecture_statement_optional_label<out concurrentStmt,label>
		)
		.

architecture_statement_with_label<out ConcurrentStatement concurrentStmt, Identifier label> =
		(.concurrentStmt=null;.)
		(
		component_instantiation_statement<out concurrentStmt,label>
		| block_statement<out concurrentStmt,label>
		| generate_statement<out concurrentStmt,label>
		)
		.
				
architecture_statement_optional_label<out ConcurrentStatement concurrentStmt, Identifier label> =
		(.concurrentStmt=null;boolean postponed=false;.)
		[POSTPONED(.postponed=true;.)] 
		(process_statement<out concurrentStmt,label,postponed>
		| concurrent_assertion_statement<out concurrentStmt,label,postponed>
		| IF(IsConcurrentSignalAssignmentStatement())concurrent_signal_assignment_statement<out concurrentStmt,label,postponed>
		| concurrent_procedure_call_statement<out concurrentStmt,label,postponed>
		)
		.		

generic_map_aspect<out AssociationList associationList> =
		GENERIC MAP LPAREN association_list<out associationList> RPAREN
		.
		
port_map_aspect<out AssociationList associationList> =
		PORT MAP LPAREN association_list<out associationList> RPAREN
		.
					
block_statement<out BlockStatement blockStmt, Identifier label> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); 
		   Expression guard_expression=null;
		   InterfaceList genericClause=null,portClause=null;
		   AssociationList genericMap=null,portMap=null;
		.)
		BLOCK [LPAREN expression<out guard_expression> RPAREN] [IS]
			[generic_clause<out genericClause> [generic_map_aspect<out genericMap> SEMICOLON]]
			[port_clause<out portClause> [port_map_aspect<out portMap> SEMICOLON]]
			{block_declarative_item<out DeclarativeItem item>(. declarativeItems.append(item);.)}
		BEGIN
			architecture_statement_list<.out Seq<ConcurrentStatement> statementList.>
		END_TOKEN BLOCK [unused_identifier] SEMICOLON 
		(. blockStmt=new BlockStatement(pos,toOption(label),toOption(guard_expression),toOption(genericClause),toOption(genericMap),toOption(portClause),toOption(portMap),declarativeItems.toList(),statementList);.)
		.
				
block_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item> 
		| variable_declaration<out item>
		| file_declaration<out item> 
		| alias_declaration<out item>
		| component_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| configuration_specification<out item> 
		| disconnection_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.
		
process_statement<out ProcessStatement processStmt,Identifier label,boolean postponed> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();
		   Seq<Name> name_list=null;
		.)
		PROCESS [LPAREN name_list<out name_list> RPAREN] [IS]
			{process_declarative_item<out DeclarativeItem item> (.declarativeItems.append(item);.)}
		BEGIN
			sequential_statement_list<.out Seq<SequentialStatement> sequentialStatements.>
		END_TOKEN [POSTPONED] PROCESS [unused_identifier] SEMICOLON
		(.processStmt=new ProcessStatement(pos,toOption(label),postponed,toOption(name_list),declarativeItems.toList(),sequentialStatements);.)
		.
		
process_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		SYNC
		(
		subprogram_declaration_or_body<out item>
		| type_declaration<out item> 
		| subtype_declaration<out item> 
		| constant_declaration<out item>
		| variable_declaration<out item> 
		| file_declaration<out item>
		| alias_declaration<out item> 
		| use_clause<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item> 
		| group_declaration<out item>
		)
		.
		
concurrent_procedure_call_statement<out ConcurrentProcedureCallStatement procedureCallStmt, Identifier label,boolean postponed> =
		(.AssociationList paramterList=null;.)
		selected_name<out SelectedName procedure_name> [LPAREN association_list<out paramterList>  RPAREN] SEMICOLON
		(.procedureCallStmt=new ConcurrentProcedureCallStatement(toOption(label),postponed,procedure_name,toOption(paramterList));.)
		.
		
concurrent_assertion_statement<out ConcurrentAssertionStatement assertStmt, Identifier label,boolean postponed> =
		(.Position pos=toPosition(la);Expression report_expression=null,severity_expression=null;.)
		ASSERT condition<out Expression expr>  [REPORT expression<out report_expression>] [SEVERITY expression<out severity_expression>] SEMICOLON
		(.assertStmt=new ConcurrentAssertionStatement(pos,toOption(label),postponed,expr,toOption(report_expression),toOption(severity_expression));.)
		.
							
concurrent_signal_assignment_statement<out ConcurrentSignalAssignmentStatement signalAssignmentStatement, Identifier label,boolean postponed> =
		(.signalAssignmentStatement=null;.)
		(
		 conditional_signal_assignment<out signalAssignmentStatement,label,postponed>
		|selected_signal_assignment<out signalAssignmentStatement,label,postponed>
		)
		.

conditional_signal_assignment<out ConcurrentConditionalSignalAssignment signalAssignment, Identifier label,boolean postponed> =
		(. 
		   MyListBuffer<ConcurrentConditionalSignalAssignment.When> elements=new MyListBuffer<ConcurrentConditionalSignalAssignment.When>();
		   boolean guarded=false;
		   DelayMechanism delay=null;
		.)
		target<out Target target> LEQ (.Position pos=toPosition(t);.) [GUARDED(.guarded=true;.)] [delay_mechanism<out delay>]
  			conditional_waveforms<elements>
			SEMICOLON
		(.signalAssignment=new ConcurrentConditionalSignalAssignment(pos,toOption(label),postponed,target,guarded,toOption(delay),elements.toList());.)
		.

conditional_waveforms<.MyListBuffer<ConcurrentConditionalSignalAssignment.When> elements.> =
		(.Expression expr=null;.)
       waveform<out Waveform waveform> [ WHEN condition<out expr> [ ELSE conditional_waveforms<elements> ] ] (.elements.prepend(new ConcurrentConditionalSignalAssignment.When(waveform,expr));.)
       .
 
selected_waveform<out ConcurrentSelectedSignalAssignment.When whenClause> =
 		waveform<out Waveform waveform> WHEN choices<out Choices choices> (.whenClause = new ConcurrentSelectedSignalAssignment.When(waveform,choices);.)
 		.  
 		
selected_signal_assignment<out ConcurrentSelectedSignalAssignment signalAssignment,Identifier label,boolean postponed> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<ConcurrentSelectedSignalAssignment.When> elements=new MyListBuffer<ConcurrentSelectedSignalAssignment.When>(); 
		   boolean guarded=false;
		   ConcurrentSelectedSignalAssignment.When when=null;
		   DelayMechanism delay=null;
		.)
		WITH expression<out Expression expr> SELECT
			target<out Target target> LEQ [GUARDED(.guarded=true;.)] [delay_mechanism<out delay>] 
			selected_waveform<out when> (.elements.append(when);.){COMMA selected_waveform<out when>(.elements.append(when);.)} SEMICOLON
			(.signalAssignment=new ConcurrentSelectedSignalAssignment(pos,toOption(label),postponed,expr,target,guarded,toOption(delay),elements.toList());.)
			.
			
target<out Target target> =
		(.target=null;.)
		(
   		name<out Name name> (.target = new Target(new Left<Name, Aggregate>(name));.)
  		| aggregate<out Aggregate aggregate> (.target = new Target(new Right<Name, Aggregate>(aggregate));.)
  		)
  		.
  		
component_instantiation_statement<out ComponentInstantiationStatement stmt, Identifier label> =
		(.
			ComponentType componentType =null;
			AssociationList genericMap=null,portMap=null;
			Position pos=toPosition(la);
			SelectedName name=null;
			Identifier architecture=null;
		.)
		( 
		  [COMPONENT] selected_name<out name> (.componentType=ComponentType.COMPONENT;.)
		  | ENTITY selected_name<out name> [LPAREN identifier<out architecture> RPAREN] (.componentType=ComponentType.ENTITY;.)
		  | CONFIGURATION selected_name<out name> (.componentType=ComponentType.CONFIGURATION;.)
		)
		[generic_map_aspect<out genericMap>]
		[port_map_aspect<out portMap>] SEMICOLON
		(.stmt=new ComponentInstantiationStatement(pos,label,componentType,name,toOption(architecture),toOption(genericMap),toOption(portMap));.)
		.
		
generate_statement<out ConcurrentStatement generateStmt, Identifier label> =
		(.generateStmt=null;.)
		(
		for_generate_statement<out generateStmt, label>
		| if_generate_statement<out generateStmt, label>
		)
		.
	
for_generate_statement<out ForGenerateStatement forGenerateStmt, Identifier label> =
		(.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
		FOR identifier<out Identifier loopIdentifier> IN discrete_range<out DiscreteRange discreteRange> GENERATE
			generate_statement_body<out body>
		END_TOKEN GENERATE [unused_identifier] SEMICOLON
		(.forGenerateStmt=new ForGenerateStatement(pos,toOption(label),loopIdentifier,discreteRange,body._1,body._2);.)
		.
		
if_generate_statement<out IfGenerateStatement ifGenerateStmt, Identifier label> =
		(.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
		IF_TOKEN condition<out Expression expr> GENERATE
			generate_statement_body<out body>
		END_TOKEN GENERATE [unused_identifier] SEMICOLON
		(.ifGenerateStmt=new IfGenerateStatement(pos,toOption(label),expr,body._1,body._2);.)
		.
		
generate_statement_body<out Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> statementList> =
		(.MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		[{block_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)} 
	    BEGIN]
	   	architecture_statement_list<.out Seq<ConcurrentStatement> concurrentStatements.>
	   	(.
	   		statementList=new Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>>(declarativeItems.toList(),concurrentStatements);
	   	.)
	   	.

sequential_statement_list<out Seq<SequentialStatement> list> =
		(.MyListBuffer<SequentialStatement> tmpList=new MyListBuffer<SequentialStatement>();.)
		{sequential_statement<out SequentialStatement stmt>(.tmpList.append(stmt);.)}
		(.list=tmpList.toList();.)
		.

sequential_statement<out SequentialStatement sequentialStatement> =
		(.sequentialStatement=null;Identifier label=null;.)
		(
		[IF(scanner.Peek().kind==_COLON) label_colon<out label>] SYNC
		(wait_statement<out sequentialStatement,label>
		| assertion_statement<out sequentialStatement,label>
		| report_statement<out sequentialStatement,label>
		| if_statement<out sequentialStatement,label>
		| case_statement<out sequentialStatement,label>
		| loop_statement<out sequentialStatement,label>
		| next_statement<out sequentialStatement,label>
		| exit_statement<out sequentialStatement,label>
		| return_statement<out sequentialStatement,label>
		| null_statement<out sequentialStatement,label>
		| IF(IsAssignmentStatement())signal_or_variable_assignment_statement<out sequentialStatement,label>
		| procedure_call_statement<out sequentialStatement,label>
		)
		)
		.
	
wait_statement<out WaitStatement waitStmt, Identifier label> =	
		(.Position pos=toPosition(la);Expression untilExpr=null,forExpression=null;Seq<Name> name_list=null;.)
		WAIT [ON name_list<out name_list>] [UNTIL condition<out untilExpr>] [FOR expression<out forExpression>] SEMICOLON
		(.waitStmt=new WaitStatement(pos,toOption(label),toOption(name_list),toOption(untilExpr),toOption(forExpression));.)
		.
				
assertion_statement<out AssertStatement assertStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression report_expression=null, severity_expression= null;.)
		ASSERT condition<out Expression expr> [REPORT expression<out report_expression>] [SEVERITY expression<out severity_expression>] SEMICOLON
		(.assertStmt=new AssertStatement(pos,toOption(label),expr,toOption(report_expression),toOption(severity_expression));.)
		.
			     
report_statement<out ReportStatement reportStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression severity_expression=null;.)
		REPORT expression<out Expression report_expression> [SEVERITY expression<out severity_expression>] SEMICOLON
		(.reportStmt=new ReportStatement(pos,toOption(label),report_expression,toOption(severity_expression));.)
		.	

signal_or_variable_assignment_statement<out SequentialStatement statement,Identifier label> =
		(.statement=null;.)
		target<out Target target> (
			signal_assignment_statement<out statement,label,target>
			| variable_assignment_statement<out statement,label,target>
		)
		.
		
variable_assignment_statement<out VariableAssignmentStatement varAssignStmt,Identifier label,Target target> =
		VAR_ASSIGN (.Position pos=toPosition(t);.) expression<out Expression expr> SEMICOLON
		(.varAssignStmt=new SimpleVariableAssignmentStatement(pos,toOption(label),target,expr);.)
		.
		
signal_assignment_statement<out SignalAssignmentStatement signalAssignStmt, Identifier label,Target target> =
		(.DelayMechanism delay=null;.)
		LEQ (.Position pos=toPosition(t);.)[delay_mechanism<out delay>] waveform<out Waveform waveform> SEMICOLON
		(.signalAssignStmt=new SimpleSignalAssignmentStatement(pos,toOption(label),target,toOption(delay),waveform);.)
		.
					
delay_mechanism<out DelayMechanism mechanism> =
		(.Expression time_expression=null;.)
		(
		TRANSPORT 
		| [REJECT expression<out time_expression>] INERTIAL
		)
		(.
			if (time_expression==null) mechanism=new DelayMechanism(DelayType.TRANSPORT,toOption(time_expression));
			else mechanism=new DelayMechanism(DelayType.INERTIAL,toOption(time_expression));
		.)
		.

waveform_element<out Waveform.Element element> =
	(.Expression time_expression=null;.)
 	expression<out Expression value_expression> [AFTER expression<out time_expression>]  
 	(.element= new Waveform.Element(value_expression,toOption(time_expression));.)
 	.
	
waveform<out Waveform waveForm> =
		(.MyListBuffer<Waveform.Element> elements=new MyListBuffer<Waveform.Element>();.)
		(
		waveform_element<out Waveform.Element element>(.elements.append(element);.) {COMMA waveform_element<out element>(.elements.append(element);.)}
		| UNAFFECTED 
		)
		(.waveForm=new Waveform(elements.toList());.)
		.
				
procedure_call_statement<out ProcedureCallStatement procedureCallStmt, Identifier label> =
		(.AssociationList paramterList=null;.)
		selected_name<out SelectedName procedure_name> [LPAREN association_list<out paramterList> RPAREN] SEMICOLON
		(.procedureCallStmt=new ProcedureCallStatement(toOption(label),procedure_name,toOption(paramterList));.)
		.
	
if_statement<out IfStatement ifStmt, Identifier label> =
		(.
		   Position pos=toPosition(la); 
		   MyListBuffer<IfStatement.IfThenPart> ifList=new MyListBuffer<IfStatement.IfThenPart>(); 
		   Seq<SequentialStatement> sequentialStatements = null;
		   Seq<SequentialStatement> else_sequential_statement = null;
		.)
		IF_TOKEN condition<out Expression if_condition> THEN
			sequential_statement_list<out sequentialStatements> (.ifList.append(new IfStatement.IfThenPart(if_condition,sequentialStatements));.)
		{ELSIF condition<out Expression elsif_condition> THEN
			 sequential_statement_list<out sequentialStatements>
			 (.ifList.append(new IfStatement.IfThenPart(elsif_condition,sequentialStatements));.)
			 }
		[ELSE	
			sequential_statement_list<out else_sequential_statement>]
		END_TOKEN IF_TOKEN [unused_identifier] SEMICOLON 
		(.ifStmt=new IfStatement(pos,toOption(label),ifList.toList(),toOption(else_sequential_statement));.)
		.

case_statement<out CaseStatement caseStmt,Identifier label> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<CaseStatement.When> alternatives=new MyListBuffer<CaseStatement.When>(); 
		.)
		CASE expression<out Expression expr> IS
			WHEN choices<out Choices choices> ARROW sequential_statement_list<.out Seq<SequentialStatement> sequentialStatements.> (.alternatives.append(new CaseStatement.When(choices,sequentialStatements));.)
			{WHEN choices<out choices> ARROW sequential_statement_list<.out sequentialStatements.> (.alternatives.append(new CaseStatement.When(choices,sequentialStatements));.)}
		END_TOKEN CASE  [unused_identifier] SEMICOLON
		(.caseStmt=new CaseStatement(pos,toOption(label),expr,alternatives.toList());.)
		.

iteration_scheme<out Either<Expression,Tuple2<Identifier,DiscreteRange>> scheme> =
		(.scheme=null;.)
		(
		WHILE condition<out Expression expr> (.scheme=new Left<Expression,Tuple2<Identifier,DiscreteRange>>(expr);.)
		| FOR identifier<out Identifier identifier> IN discrete_range<out DiscreteRange discreteRange> (.scheme=new Right<Expression,Tuple2<Identifier,DiscreteRange>>(new Tuple2<Identifier,DiscreteRange>(identifier,discreteRange));.)
		)
		.	
			
loop_statement<out SequentialStatement loopStmt, Identifier label> =
		(.Position pos=toPosition(la);Either<Expression,Tuple2<Identifier,DiscreteRange>> stmtType=null;.)
		[iteration_scheme<out stmtType>] LOOP
			sequential_statement_list<.out Seq<SequentialStatement> sequentialStatements.>
		END_TOKEN LOOP [unused_identifier] SEMICOLON
		(.		
			if (stmtType!=null){
				if (stmtType instanceof Left) loopStmt=new WhileStatement(pos,toOption(label),((Left<Expression,Tuple2<Identifier,DiscreteRange>>)stmtType).a,sequentialStatements);
				else {
					Tuple2<Identifier,DiscreteRange> r=((Right<Expression,Tuple2<Identifier,DiscreteRange>>)stmtType).b;
					loopStmt=new ForStatement(pos,toOption(label),r._1,r._2,sequentialStatements);
				}
			}else loopStmt=new LoopStatement(pos,toOption(label),sequentialStatements);
		.)
		.

next_statement<out NextStatement nextStmt,Identifier label> =
		(.Position pos=toPosition(la);Identifier identifier=null;Expression expr=null;.)
		NEXT [identifier<out identifier>] [WHEN condition<out expr>] SEMICOLON 
		(.nextStmt=new NextStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
		.

exit_statement<out ExitStatement exitStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression expr=null;Identifier identifier=null;.)
		EXIT [identifier<out identifier>] [WHEN condition<out expr>] SEMICOLON 
		(.exitStmt=new ExitStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
		.

return_statement<out ReturnStatement returnStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression expr=null;.)
		RETURN [expression<out expr>] SEMICOLON 
		(.returnStmt=new ReturnStatement(pos,toOption(label),toOption(expr));.)
		.
	
null_statement<out NullStatement nullStmt, Identifier label> =
		(.Position pos=toPosition(la);.)
		NULL SEMICOLON
		(.nullStmt=new NullStatement(pos,toOption(label));.)
		.
		
interface_element_procedure<out InterfaceList.AbstractInterfaceElement element> =
		(.element=null;.)
		(
		IF(IsInterfaceConstantDeclaration())interface_constant_declaration<out element>
		| IF(IsInterfaceVariableDeclaration())interface_variable_declaration<out element>
		| interface_signal_declaration_procedure<out element>
		| interface_file_declaration<out element>
		)
		.
		
interface_element_function<out InterfaceList.AbstractInterfaceElement element> =
		(.element=null;.)
		(
		 interface_constant_declaration<out element>
		| interface_signal_declaration_function<out element>
		| interface_file_declaration<out element>
		)
		.
		
parameter_interface_list_procedure<out InterfaceList list> =
		(.
		  MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>();
		  InterfaceList.AbstractInterfaceElement element=null;
		.)
		interface_element_procedure<out element>(.elements.append(element);.) {SEMICOLON interface_element_procedure<out element> (.elements.append(element);.)} 
		(.list=new InterfaceList(elements.toList());.)
		.
		
parameter_interface_list_function<out InterfaceList list> =
		(.
		  MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>();
		  InterfaceList.AbstractInterfaceElement element=null;
		.)
		interface_element_function<out element> (.elements.append(element);.) {SEMICOLON interface_element_function<out element> (.elements.append(element);.)} 
		(.list=new InterfaceList(elements.toList());.)
		.
			
interface_constant_declaration<out InterfaceList.InterfaceConstantDeclaration constElement> =
		(.Expression expr=null;.)
		[CONSTANT] identifier_list<.out Seq<Identifier> list.> COLON [IN] subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] 
		(.constElement=new InterfaceList.InterfaceConstantDeclaration(list,subType,toOption(expr));.)
		.

interface_signal_declaration_procedure<out InterfaceList.InterfaceSignalDeclaration signalElement> =
		(.Expression expr=null;boolean bus=false;InterfaceMode mode=null;.)
		[SIGNAL] identifier_list<.out Seq<Identifier> list.> COLON [interface_mode<out mode>] subtype_indication<out SubTypeIndication subType> [BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>]
		(.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(mode),subType,bus,toOption(expr));.)
		.
		
interface_signal_declaration_function<out InterfaceList.InterfaceSignalDeclaration signalElement> =
		(.Expression expr=null;boolean bus=false;.)
		SIGNAL identifier_list<.out Seq<Identifier> list.> COLON [IN] subtype_indication<out SubTypeIndication subType> [BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>]
		(.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(InterfaceMode.IN),subType,bus,toOption(expr));.)
		.
	
interface_variable_declaration<out InterfaceList.InterfaceVariableDeclaration varElement> =
		(.Expression expr=null;InterfaceMode mode=null;.)
		[VARIABLE] identifier_list<.out Seq<Identifier> list.> COLON [interface_mode<out mode>] subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>]
		(.varElement=new InterfaceList.InterfaceVariableDeclaration(list,toOption(mode),subType,toOption(expr));.)
		.
	
interface_mode<out InterfaceMode mode> =
		(.mode=null;.)
		(
		IN (.mode=InterfaceMode.IN;.)
		|OUT (.mode=InterfaceMode.OUT;.)
		|INOUT (.mode=InterfaceMode.INOUT;.)
		|BUFFER (.mode=InterfaceMode.BUFFER;.)
		|LINKAGE (.mode=InterfaceMode.LINKAGE;.)
		)
		.

interface_file_declaration<out InterfaceList.InterfaceFileDeclaration fileElement> =
		FILE identifier_list<.out Seq<Identifier> list.> COLON subtype_indication<out SubTypeIndication subType>
		(.fileElement=new InterfaceList.InterfaceFileDeclaration(list,subType);.)
		.

association_element<out AssociationList.Element element> =
		(.Identifier identifier=null;Name name=null;Option<Expression> actualPart=null;.)
		[IF(IsFormalPartInAssociationElement()) formal_part<out name> ARROW] actual_part<out actualPart> (.element=new AssociationList.Element(toOption(name),actualPart);.)
		.	
		  
association_list<out AssociationList list> =
		(.
		  MyListBuffer<AssociationList.Element> elements=new MyListBuffer<AssociationList.Element>();
		  AssociationList.Element element=null;
		.)
		association_element<out element> (.elements.append(element);.) {COMMA association_element<out element> (.elements.append(element);.)}
		(.list=new AssociationList(elements.toList());.)
		.

formal_part<out Name formal_part> =
		name<out formal_part>
		.
		
actual_part<out Option<Expression> actual_part> = 
		(.Expression expr=null;.)
		(
		expression<out expr> 
		| OPEN
		)
		(.actual_part = toOption(expr);.)
		.
			
condition<out Expression expr> =
		expression<out expr>
		.
	 
expression<out Expression expr> =
		(.Tuple2<Position,Operators.Logical> op=null;.)
		relation<out expr> 
	    {logical_operator<out op> relation<out Expression right> (.expr=new LogicalExpression(op._1,expr,op._2,right);.)}
	    .

logical_operator<out Tuple2<Position,Operators.Logical> op> =
		(.
		  Position pos=toPosition(la);
		  Operators.Logical logOp=null;
		.)
		(
		AND (.logOp=Operators.Logical.AND;.)
		|OR (.logOp=Operators.Logical.OR;.)
		|XOR (.logOp=Operators.Logical.XOR;.)
		|XNOR (.logOp=Operators.Logical.XNOR;.)
		|NAND (.logOp=Operators.Logical.NAND;.)
		|NOR (.logOp=Operators.Logical.NOR;.)
		)
		(.op=new Tuple2<Position,Operators.Logical>(pos,logOp);.)
		.

relation<out Expression rel> =
	(.Tuple2<Position,Operators.Relation> op=null;.)
    shift_expression<out rel>
    [relational_operator<out op> shift_expression<out Expression right> (.rel=new Relation(op._1,rel,op._2,right);.)]
    .

relational_operator<out Tuple2<Position,Operators.Relation> op> =
		(.
			Position pos=toPosition(la);
			Operators.Relation relOp=null;
		.)
		(
	    EQ (.relOp=Operators.Relation.EQ;.)
	  | NEQ (.relOp=Operators.Relation.NEQ;.)
	  | LT (.relOp=Operators.Relation.LT;.)
	  | LEQ (.relOp=Operators.Relation.LEQ;.)
	  | GT (.relOp=Operators.Relation.GT;.)
	  | GEQ (.relOp=Operators.Relation.GEQ;.)
	  )
	  (.op=new Tuple2<Position,Operators.Relation>(pos,relOp);.)
	  .

	
shift_expression<out Expression shiftExpr> =
	(.Tuple2<Position,Operators.Shift> op=null;.)
    simple_expression<out shiftExpr>
    [shift_operator<out op> simple_expression<out Expression right> (.shiftExpr=new ShiftExpression(op._1,shiftExpr,op._2,right);.)]
    .

shift_operator<out Tuple2<Position,Operators.Shift> op> =
		(.  
		    Position pos=toPosition(la);
		    Operators.Shift shiftOp=null;
		.)
		(
		SLL  (.shiftOp=Operators.Shift.SLL;.)
		|SRL (.shiftOp=Operators.Shift.SRL;.)
		|SLA (.shiftOp=Operators.Shift.SLA;.)
		|SRA (.shiftOp=Operators.Shift.SRA;.)
		|ROL (.shiftOp=Operators.Shift.ROL;.)
		|ROR (.shiftOp=Operators.Shift.ROR;.)
		)
		(.op=new Tuple2<Position,Operators.Shift>(pos,shiftOp);.)
		.
		
simple_expression<out Expression simpleExpr> =
	  (.Tuple2<Position,Operators.Sign> sign=null;Tuple2<Position,Operators.Add> op=null;.)
	  [sign<out sign>] term<out simpleExpr> 
	  (.if (sign!=null) simpleExpr=new SimpleExpression(sign._1,sign._2,simpleExpr);.)
	  {adding_operator<out op> term<out Expression right> (.simpleExpr=new SimpleExpression(op._1,simpleExpr,op._2,right);.)}
	  .

sign<out Tuple2<Position,Operators.Sign> op> =
		(.  
		    Position pos=toPosition(la);
		    Operators.Sign signOp=null;
		.)
		(
		PLUS (.signOp=Operators.Sign.PLUS;.)
		|MINUS (.signOp=Operators.Sign.MINUS;.)
		)
		(.op=new Tuple2<Position,Operators.Sign>(pos,signOp);.)
		.	
		
adding_operator<out Tuple2<Position,Operators.Add> op> =
		(.  
		    Position pos=toPosition(la);
		    Operators.Add addOp=null;
		.)
		(
		PLUS (.addOp=Operators.Add.PLUS;.)
		|MINUS (.addOp=Operators.Add.MINUS;.)
		|AMPERSAND (.addOp=Operators.Add.AMPERSAND;.)
		)
		(.op=new Tuple2<Position,Operators.Add>(pos,addOp);.)
		.

multiplying_operator<out Tuple2<Position,Operators.Term> op>=
		(.  
		    Position pos=toPosition(la);
		    Operators.Term mulOp=null;
		.)
		(
		MUL (.mulOp=Operators.Term.MUL;.)
		|DIV (.mulOp=Operators.Term.DIV;.)
		|MOD (.mulOp=Operators.Term.MOD;.)
		|REM (.mulOp=Operators.Term.REM;.)
		)
		(.op=new Tuple2<Position,Operators.Term>(pos,mulOp);.)
		.

term<out Expression term> =
	   (.Tuple2<Position,Operators.Term> op=null;.)
	   factor<out term>
	  [ multiplying_operator<out op> factor<out Expression right> (.term = new Term(op._1,term,op._2,right);.)]
	  .
 
factor<out Expression factor> =
	(.factor=null;.)
	(
	primary<out factor> [DOUBLESTAR (.Position pos=toPosition(t);.) primary<out Expression right> (.factor = new Factor(pos,factor,Operators.Factor.POW,toOption(right));.)]
	| ABS (.Position pos=toPosition(t);.) primary<out Expression left> (.factor = new Factor(pos,left,Operators.Factor.ABS);.)
	| NOT (.Position pos=toPosition(t);.) primary<out Expression left> (.factor = new Factor(pos,left,Operators.Factor.NOT);.)
	)
	.

primary<out Expression expr> =
	(.expr=null;.)
	(
	 
	 //selected_name qualified_expression should be handled by name_attribute_part
	   name<out Name name> (.expr=new NameExpression(name);.)
	 | literal<out expr> 
	 | allocator<out expr>
	 | aggregate<out Aggregate aggregate> (.expr=new AggregateExpression(aggregate);.)
	 )
	 .

allocator<out Expression newExpression> =
	(.Position pos=toPosition(la);newExpression=null;.)
	NEW selected_name<out SelectedName selectedName>  
	 	( qualified_expression<out Expression expr,selectedName> (.newExpression=new NewExpression(pos,new Left<Expression, SubTypeIndication>(expr));.)
	 	| [index_constraint<.out Seq<DiscreteRange> ranges.> 	 			
	 			(.
	 			  Either<Range,Seq<DiscreteRange>> constraint=new Right<Range,Seq<DiscreteRange>>(ranges);
				  newExpression=new NewExpression(pos,new Right<Expression, SubTypeIndication>(new SubTypeIndication(selectedName,toOption(constraint))));
				.)]
	 	)
	 	.

/*
function_call<out FunctionCallExpression functionCall> =
		(.AssociationList parameter_association_list=null;.)
		selected_name<out SelectedName function_name> [LPAREN association_list<out parameter_association_list> RPAREN]
		(.functionCall=new FunctionCallExpression(function_name,toOption(parameter_association_list));.)
		.
*/
	
qualified_expression<out QualifiedExpression expr,SelectedName typeName> =
		APOSTROPHE aggregate<out Aggregate aggregate>
		(.expr=new QualifiedExpression(typeName,new AggregateExpression(aggregate));.)
		.

selected_name_list<out Seq<SelectedName> list> =
		(.
			MyListBuffer<SelectedName> tmpList=new MyListBuffer<SelectedName>();
			SelectedName name;
		.)
		selected_name<out name> (.tmpList.append(name);.) {COMMA selected_name<out name> (.tmpList.append(name);.) }
		(.list=tmpList.toList();.)
		.
		
selected_name<out SelectedName name> =
		(. MyListBuffer<Identifier> parts=new MyListBuffer<Identifier>();.)
		name_prefix<out Identifier prefix> { name_selected_part<out Name.SelectedPart selectedPart> (.parts.append(selectedPart.identifier());.)}
		(.parts.prepend(prefix); name =new SelectedName(parts.toList());.)
		.

name_list<out Seq<Name> list> =
		(.MyListBuffer<Name> tmpList=new MyListBuffer<Name>();.)
		name<out Name name> (.tmpList.append(name);.) {COMMA name<out name> (.tmpList.append(name);.)}
		(.list=tmpList.toList();.)
		.
			
name<out Name name> =
		(.MyListBuffer<Name.Part> parts=new MyListBuffer<Name.Part>();.)
		name_prefix<out Identifier prefix> {name_part<out Name.Part part> (.parts.append(part);.)}
	  	(.name =new Name(prefix,parts.toList());.)
  		.

name_prefix<out Identifier identifier> =
	(.identifier=null;.)
	(
 	  identifier<out identifier>
 	| STRING_LITERAL (.identifier=toIdentifier(t);.)
 	)
 	.
 	
name_part<out Name.Part part> =
	 (.part=null;.)
	 (
  	 name_selected_part<out part>
   	 | name_attribute_part<out part>
   	 | IF(IsNameSlicePart())name_slice_part<out part>
   	 //| IF(IsNameAssociationListPart())name_association_list_part<out part>
   	 //| name_indexed_part<out part> handled by name_association_list_part
   	 | name_association_list_part<out part>
  	 )
  	 .
		
name_selected_part<out Name.SelectedPart part> =
		(.part=null;.)
		DOT (
		identifier<out Identifier identifier>(.part= new Name.SelectedPart(identifier);.)
		|CHARACTER_LITERAL (.part= new Name.SelectedPart(toIdentifier(t));.)
		|STRING_LITERAL(.part= new Name.SelectedPart(toIdentifier(t));.)
		|ALL(.part= new Name.SelectedPart(toIdentifier(t));.)
		)
		.
		  	 
name_association_list_part<out Name.AssociationListPart part> = 
		LPAREN association_list<out AssociationList list> RPAREN (.part=new Name.AssociationListPart(list);.)
		.

name_slice_part<out Name.SlicePart part> =
		LPAREN discrete_range<out DiscreteRange discreteRange> RPAREN  (.part=new Name.SlicePart(discreteRange);.)
		.
/*				
name_indexed_part<out Name.IndexPart part> =
		(. MyListBuffer<Expression> indexes=new MyListBuffer<Expression>(); .)
		 LPAREN expression<out Expression expr> (.indexes.append(expr);.) {COMMA expression<out expr> (.indexes.append(expr);.)} RPAREN (.part=new Name.IndexPart(indexes.toList());.) 
		 .
*/

name_attribute_part<out Name.AttributePart part> =
		(.Signature signature=null;Identifier identifier=null;Expression expr=null;.)
		[signature<out signature>] APOSTROPHE (identifier<out identifier>|RANGE (.identifier=toIdentifier(t);.)) [LPAREN expression<out expr> RPAREN]  
		(.part=new Name.AttributePart(toOption(signature),identifier,toOption(expr));.)
		.
		
signature<out Signature signature> =
		(.Seq<SelectedName> list=null;SelectedName returnType=null;.)
		LBRACKET [selected_name_list<out list>] [RETURN type_mark<out returnType>] RBRACKET
		(.signature =new Signature(toOption(list),toOption(returnType));.)
		.
		
literal<out Expression literal> =
		(. LiteralType literalType=null;.)
		(
		REAL_LITERAL (.literalType=LiteralType.REAL_LITERAL;.)
		| INTEGER_LITERAL (.literalType=LiteralType.INTEGER_LITERAL;.)
		| BASED_LITERAL (.literalType=LiteralType.BASED_LITERAL;.)
		| CHARACTER_LITERAL (.literalType=LiteralType.CHARACTER_LITERAL;.)
		| BIT_STRING_LITERAL (.literalType=LiteralType.BIT_STRING_LITERAL;.)
		| NULL (.literalType=LiteralType.NULL_LITERAL;.)
		)
		(.literal =new Literal(toPosition(t),t.val,literalType);.)
		[IF((t.kind==_INTEGER_LITERAL || t.kind==_REAL_LITERAL) && (la.kind==_BASIC_IDENTIFIER || la.kind==_EXTENDED_IDENTIFIER)) identifier<out Identifier unit> (.literal = new PhysicalLiteral((Literal)literal,unit);.)]
		.
	
physical_literal<out PhysicalLiteral literal> =
		(.
			String text=la.val;
			LiteralType literalType=null;
			Position pos=toPosition(la);
		.)
		(
		INTEGER_LITERAL (.literalType=LiteralType.INTEGER_LITERAL;.)
		|REAL_LITERAL (.literalType=LiteralType.REAL_LITERAL;.)
		)
		identifier<out Identifier unit_name>
		(.literal =new PhysicalLiteral(pos,text,unit_name,literalType);.)
		.
	
element_association<out Aggregate.ElementAssociation element> =
		(.Choices choice=null;.) 
	    [IF(IsChoiceInElementAssociation()) choices<out choice> ARROW] expression<out Expression expr>
	  	(.element=new Aggregate.ElementAssociation(toOption(choice),expr);.)
	  	.

aggregate<out Aggregate aggregate> =
		(. MyListBuffer<Aggregate.ElementAssociation> elements=new MyListBuffer<Aggregate.ElementAssociation>(); .)
		LPAREN  element_association<out Aggregate.ElementAssociation element>(.elements.append(element);.) {COMMA element_association<out element> (.elements.append(element);.)} RPAREN
		(.aggregate =new Aggregate(elements.toList());.)
		.

choice<out Choices.Choice choice> =
		(.choice=null;.)
		(
		IF(IsRangeInChoice())discrete_range<out DiscreteRange range> (.Either<DiscreteRange, Expression> left=new Left<DiscreteRange, Expression>(range);choice =new Choices.Choice(toOption(left));.)
		| simple_expression<out Expression expr> (.Either<DiscreteRange, Expression> right=new Right<DiscreteRange, Expression>(expr);choice = new Choices.Choice(toOption(right));.)
		| OTHERS (.choice =new Choices.Choice();.)
		)
		.	

choices<out Choices choices> =
		(. MyListBuffer<Choices.Choice> elements=new MyListBuffer<Choices.Choice>(); .)
		choice<out Choices.Choice choice> (.elements.append(choice);.) { BAR choice<out choice> (.elements.append(choice);.)}
		(.choices =new Choices(elements.toList());.)
		.
	
identifier_list<out Seq<Identifier> list> =
		(.
			MyListBuffer<Identifier> tmpList=new MyListBuffer<Identifier>();
			Identifier identifier=null;
		.)
		identifier<out identifier> (.tmpList.append(identifier);.) {COMMA identifier<out identifier> (.tmpList.append(identifier);.) } 
		(.list=tmpList.toList();.)
		.
		
unused_identifier = identifier<out Identifier unused>.
			
identifier<out Identifier id> =
		(.id=null;.)
		(
		BASIC_IDENTIFIER (. id=toIdentifier(t);.)
		| EXTENDED_IDENTIFIER (. id=toIdentifier(t,false);.)
		)
		.

label_colon<out Identifier label> =
		identifier<out label> COLON
		.
		
END VHDL.
