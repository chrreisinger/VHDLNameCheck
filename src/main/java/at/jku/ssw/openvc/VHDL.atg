/* imports */
import at.jku.ssw.openvc.ast.*;
import at.jku.ssw.openvc.ast.concurrentStatements.*;
import at.jku.ssw.openvc.ast.declarations.*;
import at.jku.ssw.openvc.ast.expressions.*;
import at.jku.ssw.openvc.ast.sequentialStatements.*;
import scala.Either;
import scala.Left;
import scala.Right;
import scala.Tuple2;
import scala.Option;
import scala.Some;
import scala.None;
import scala.collection.Seq;
import scala.collection.mutable.ListBuffer;

COMPILER VHDL
  /* arbitrary Java code */
  
  	public static class MyListBuffer<T> {
		ListBuffer<T> impl=new ListBuffer<T>();
		public void append(T x){
			if (x!=null) impl.$plus$eq(x);
		}
		public void appendAll(Seq<T> x){
			if (x!=null) impl.appendAll(x);
		}
		public void prepend(T x){
			if (x!=null) impl.$plus$eq$colon(x);
		}
		public Seq<T> toList(){
			return impl.toList();
		}
		public boolean isEmpty(){
			return impl.isEmpty();
		}
	}
	
	public static <T> Option<T> toOption(T x){return Option.apply(x);}
	
  //group_template:GROUP identifier IS LPAREN ...
  //group_declaration:GROUP identifier COLON ...
  //la == GROUP
boolean IsGroupTemplate() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_IS && next.kind!=_COLON && next.kind!=_SEMICOLON); 
	return next.kind==_IS;
}

  //attribute_declaration: ATTRIBUTE identifier COLON type_mark SEMICOLON 
  //attribute_specification: ATTRIBUTE identifier OF entity_name_list COLON entity_class IS expression SEMICOLON 
  //la == ATTRIBUTE
boolean IsAttributeDeclaration() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_COLON && next.kind!=_OF && next.kind!=_SEMICOLON);
	return next.kind==_COLON;
}

	//physical_type_definition: RANGE range UNITS ...
	//integer_or_floating_point_type_definition: RANGE range SEMICOLON
	//la == RANGE
boolean IsPhysicalType() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_UNITS && next.kind!=_SEMICOLON);
	return next.kind==_UNITS;
}

	//constrained array: LPAREN index_subtype_definition (COMMA index_subtype_definition)* RPAREN OF subtype_indication
	//index_subtype_definition: type_mark RANGE BOX
	//index_constraint: LPAREN discrete_range (COMMA  discrete_range)* RPAREN
	//la==LPAREN
boolean IsIndexSubtypeDefinition() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_BOX && next.kind!=_SEMICOLON && next.kind!=_RPAREN && next.kind!=_LPAREN);
	return next.kind==_BOX;
}
	//procedure_call_statement: selected_name [LPAREN association_list RPAREN] SEMICOLON
	//signal_or_variable_assignment_statement: target (VAR_ASSIGN|LEQ) ....
	//target: name | aggregate
boolean IsAssignmentStatement() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_VAR_ASSIGN && next.kind!=_LEQ && next.kind!=_SEMICOLON);
	return next.kind==_VAR_ASSIGN || next.kind==_LEQ;
}
	//concurrent_signal_assignment_statement: (target LEQ | WITH) ....
	//concurrent_procedure_call_statement: selected_name [LPAREN association_list RPAREN] SEMICOLON
boolean IsConcurrentSignalSssignmentStatement() {
	Token next;
	do {
		next = scanner.Peek();
	}while (next.kind!=_LEQ && next.kind!=_WITH && next.kind!=_SEMICOLON);
	return next.kind==_LEQ || next.kind==_WITH;
}

private Position toPosition(Token token){
 return new Position(token.line,token.col);
}    

private Identifier toIdentifier(Token token){
	return toIdentifier(token,true);
}

private Identifier toIdentifier(Token token,boolean toLowerCase){
    		if (token.kind!=_STRING_LITERAL && token.kind!=_CHARACTER_LITERAL){
    			return new Identifier(toPosition(token),toLowerCase?token.val.toLowerCase():token.val.replace("\\\\","\\"));   
    		}else{
    			return new Identifier(toPosition(token),token.val);
    		}
}      
/*--------------------------------------------------------------------*/


CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  DIGIT = '0'..'9'.
  	LOWER_CASE_LETTER = 'a'..'z' .//| '\u00df'..'\u00f6' | '\u00f8'.. '\u00ff'. //a-z,ß - ö, ø - ÿ
	UPPER_CASE_LETTER = 'A'..'Z' .//| '\u00c0'..'\u00d6' | '\u00d8' .. '\u00de'. //A - Z,À - Ö, Ø - Þ
	SPECIAL_CHARACTER = "#&\'()*+,-./:;<=>[]_|".
TOKENS
	
	
	//BASIC_IDENTIFIER = LETTER { LETTER_OR_DIGIT | '_' }.

	//EXTENDED_IDENTIFIER = '\\' ( '\"' | '\\\\' | GRAPHIC_CHARACTER )+ '\\'.
	   		 	
	//BASED_LITERAL = INTEGER '#' BASED_INTEGER [DOT BASED_INTEGER] '#' EXPONENT? .
	
	//INTEGER_LITERAL = INTEGER [EXPONENT].
	    
	//REAL_LITERAL = INTEGER  DOT INTEGER  [EXPONENT] .
	
	/*  
	SPACE_CHARACTER = ' ' | '\u00a0'. //space, non-breaking space
	  
	OTHER_SPECIAL_CHARACTER =
	   '!' | '$' | '%' | '@' | '?' | '^' | '`' | '{' | '}' | '~'
	  | '\u00a1'..'\u00bf' | '\u00d7' | '\u00f7'.//  ¡ - ¿, × - ÷
	  
	//STRING_LITERAL = '\"' { '\"\"' | '\\' | GRAPHIC_CHARACTER } '\"'.
	*/
	  
	//BIT_STRING_LITERAL = ('b' | 'o' | 'x') '\"' [BASED_INTEGER] '\"'.
	
	//EXTENDED_DIGIT = DIGIT | LETTER.
	
	//BASED_INTEGER = EXTENDED_DIGIT {['_'] EXTENDED_DIGIT}.

	INTEGER = DIGIT { ['_'] DIGIT}.

	//EXPONENT = 'e' [ '+' | '-' ] INTEGER.

	//LETTER_OR_DIGIT = LETTER| DIGIT.

	LETTER = UPPER_CASE_LETTER| LOWER_CASE_LETTER.

//TODO 
APOSTROPHE ="blub".
CHARACTER_LITERAL ="blubx".
EXTENDED_IDENTIFIER ="blubx2".
BASIC_IDENTIFIER ="blubx3".
STRING_LITERAL ="blubx24".

  	ABS="abs".
	ACCESS="access".
	AFTER="after".
	ALIAS="alias".
	ALL="all".
	AND="and".
	ARCHITECTURE="architecture".
	ARRAY="array".
	ASSERT="assert".
	ATTRIBUTE="attribute".
	BEGIN="begin".
	BLOCK="block".
	BODY="body".
	BUFFER="buffer".
	BUS="bus".
	CASE="case".
	COMPONENT="component".
	CONFIGURATION="configuration".
	CONSTANT="constant".
	DISCONNECT="disconnect".
	DOWNTO="downto".
	ELSE="else".
	ELSIF="elsif".
	END_TOKEN="end".
	ENTITY="entity".
	EXIT="exit".
	FILE="file".
	FOR="for".
	FUNCTION="function".
	GENERATE="generate".
	GENERIC="generic".
	GROUP="group".
	GUARDED="guarded".
	IF_TOKEN="if".
	IMPURE="impure".
	IN="in".
	INERTIAL="inertial".
	INOUT="inout".
	IS="is".
	LABEL="label".
	LIBRARY="library".
	LINKAGE="linkage".
	LITERAL="literal".
	LOOP="loop".
	MAP="map".
	MOD="mod".
	NAND="nand".
	NEW="new".
	NEXT="next".
	NOR="nor".
	NOT="not".
	NULL="null".
	OF="of".
	ON="on".
	OPEN="open".
	OR="or".
	OTHERS="others".
	OUT="out".
	PACKAGE="package".
	PORT="port".
	POSTPONED="postponed".
	PROCEDURE="procedure".
	PROCESS="process".
	PROTECTED="protected".
	PURE="pure".
	RANGE="range".
	RECORD="record".
	REGISTER="register".
	REJECT="reject".
	REM="rem".
	REPORT="report".
	RETURN="return".
	ROL="rol".
	ROR="ror".
	SELECT="select".
	SEVERITY="severity".
	SHARED="shared".
	SIGNAL="signal".
	SLA="sla".
	SLL="sll".
	SRA="sra".
	SRL="srl".
	SUBTYPE="subtype".
	THEN="then".
	TO_TOKEN="to".
	TRANSPORT="transport".
	TYPE="type".
	UNAFFECTED="unaffected".
	UNITS="units".
	UNTIL="until".
	USE="use".
	VARIABLE="variable".
	WAIT="wait".
	WHEN="when".
	WHILE="while".
	WITH="with".
	XNOR="xnor".
	XOR="xor".
  		
  	DOUBLESTAR    = "**".
  	LEQ           = "<=".
  	GEQ           = ">=".
  	ARROW         = "=>".
  	NEQ           = "/=".
  	VAR_ASSIGN    = ":=".
  	BOX           = "<>".
  	DBLQUOTE      = "\"".
  	SEMICOLON     = ";".
  	COMMA         = ",".
  	AMPERSAND     = "&".
  	LPAREN        = "(".
  	RPAREN        = ")".
  	LBRACKET      = "[".
  	RBRACKET      = "]".
  	COLON         = ":".
  	MUL           = "*".
  	DIV           = "/".
  	PLUS          = "+".
  	MINUS         = "-".
  	LT            = "<".
 	GT            = ">".
  	EQ            = "=".
  	BAR           = "|".
  	DOT           = ".".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab
/*--------------------------------------------------------------------*/

PRODUCTIONS

VHDL<out DesignFile designFile> =	
		(.MyListBuffer<DesignUnit> units=new MyListBuffer<DesignUnit>(); .)
		{design_unit<out DesignUnit designUnit> (. units.append(designUnit); .) } //TODO change to *
		(.designFile=new DesignFile(units.toList());.)
		.

design_unit<out DesignUnit designUnit> =
(.
	MyListBuffer<Identifier> libraries=new MyListBuffer<Identifier>();
	MyListBuffer<UseClause> useClauses=new MyListBuffer<UseClause>();
.)
		{
		library_clause<out Seq<.Identifier.> identifierList> (.libraries.appendAll(identifierList);.)
		|use_clause<out UseClause useClause> (.useClauses.append(useClause);.)
		} (.Position pos=toPosition(la);.) library_unit<out LibraryUnit libraryUnit>
		(.designUnit=new DesignUnit(pos,libraries.toList(),useClauses.toList(),toOption(libraryUnit));.)
		.

library_unit<out LibraryUnit libraryUnit> =
		(.libraryUnit=null;.)
		(
		entity_declaration<out libraryUnit>
		| architecture_body<out libraryUnit> 
		| IF(scanner.Peek().kind==_BODY)package_body<out libraryUnit>
		| package_declaration<out libraryUnit> 
		| configuration_declaration<out libraryUnit> 
		)
		.	
		
library_clause<out Seq<Identifier> identifierList> =
	LIBRARY identifier_list<out identifierList> SEMICOLON 
	.

generic_clause<out InterfaceList genericList> =
	   GENERIC LPAREN generic_interface_list<out genericList> RPAREN SEMICOLON
	   .

generic_interface_list<out InterfaceList list> =
	(. MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    interface_constant_declaration<out InterfaceList.InterfaceConstantDeclaration declaration> (.elements.append(declaration);.) { SEMICOLON interface_constant_declaration<out declaration> (.elements.append(declaration); .)}
    (. list=new InterfaceList(elements.toList());.)
    	.
    
port_clause<out InterfaceList portList> =
	 PORT LPAREN port_interface_list<out portList> RPAREN SEMICOLON
	.

port_interface_list<out InterfaceList list> =
	(. MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>(); .)
    interface_signal_declaration_procedure<out InterfaceList.InterfaceSignalDeclaration declaration> (.elements.append(declaration); .) { SEMICOLON interface_signal_declaration_procedure<out declaration> (.elements.append(declaration);.)}
    (.list=new InterfaceList(elements.toList());.)
    	.
	
entity_declaration<out EntityDeclaration entityDecl> =
(.
 	MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();
 	MyListBuffer<ConcurrentStatement> concurrentStmts=new MyListBuffer<ConcurrentStatement>();
 	InterfaceList genericClause=null,portClause=null;
 	ConcurrentStatement stmt=null;
 	Identifier label=null;
 	boolean postponed=false;
.)
		ENTITY identifier<out Identifier start_identifier> IS
			[generic_clause<out genericClause>]
			[port_clause<out portClause>]
			{entity_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item); .)} 
		[BEGIN
			{[label_colon<out label>] [POSTPONED (.postponed=true;.)] 
			(concurrent_assertion_statement<out stmt,label,postponed>
			| concurrent_procedure_call_statement<out stmt,label,postponed>
			| process_statement<out stmt,label,postponed>
			)
			(.concurrentStmts.append(stmt);.)
			}]
		END_TOKEN [ENTITY] [unused_identifier] SEMICOLON
		(.entityDecl=new EntityDeclaration(start_identifier,toOption(genericClause),toOption(portClause),declarativeItems.toList(),concurrentStmts.toList());.)
		.

entity_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| disconnection_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.
		
architecture_body<out ArchitectureDeclaration archDecl> =
		(.MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		ARCHITECTURE identifier<out Identifier start_identifier> OF selected_name<out SelectedName entityName> IS
			{block_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item); .)}
		BEGIN
			architecture_statement_list<out Seq<.ConcurrentStatement.> statementList>
		END_TOKEN [ARCHITECTURE] [unused_identifier] SEMICOLON
		(.archDecl=new ArchitectureDeclaration(start_identifier,declarativeItems.toList(),entityName,statementList); .)
		.
		
configuration_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		| use_clause<out item> 
		| group_declaration<out item> 
		| attribute_specification<out item>
		)
		.
		
configuration_declaration<out ConfigurationDeclaration configDecl> =
		(.MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		CONFIGURATION identifier<out Identifier start_identifier> OF selected_name<out SelectedName entityName> IS
			{configuration_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
			block_configuration<out BlockConfiguration blockConfig>
		END_TOKEN [CONFIGURATION] [unused_identifier] SEMICOLON
		(.configDecl=new ConfigurationDeclaration(start_identifier,declarativeItems.toList(),entityName,blockConfig);.)
		.
/* TODO
block_configuration_index returns [Either[DiscreteRange,Expression\] node]
	:	  (discrete_range)=>discrete_range {$node=new Left($discrete_range.discreteRange)}
		  |expression {$node=new Right($expression.expr)}
		  .
*/	
block_configuration_index = "asjdöflk" .

block_specification<out BlockConfigurationSpecification blockSpec>  = 
		//could be a block_statement_label or generate_statement_label
		(.blockSpec=null;.)
		(
		  IF(scanner.Peek().kind==_LPAREN) identifier<out Identifier identifier> [LPAREN block_configuration_index RPAREN]
			(.blockSpec=new BlockConfigurationSpecification(new Right(Tuple2(identifier,$block_configuration_index.node)));.)
		 | selected_name<out SelectedName selectedName> (.blockSpec=new BlockConfigurationSpecification(new Left(selectedName));.)
		)
	 	 .
block_configuration<out BlockConfiguration blockConfig> =
		(.
			MyListBuffer<UseClause> useClauses=new MyListBuffer<UseClause>();
			MyListBuffer<Object> configurations=new MyListBuffer<Object>();
		.)
		FOR block_specification<out BlockConfigurationSpecification blockSpec>
		{use_clause<out UseClause useClause> (.useClauses.append(useClause);.)}
		{
			block_configuration<out BlockConfiguration blockConfiguration> (.configurations.append(blockConfiguration);.)
			|component_configuration<out ComponentConfiguration componentConfiguration> (.configurations.append(componentConfiguration);.)
		}
		END_TOKEN FOR SEMICOLON 
		(.blockConfig=new BlockConfiguration(blockSpec,useClauses.toList(),configurations.toList());.)
		.
		
component_configuration<out ComponentConfiguration componentConfig> =
		(.BlockConfiguration blockConfiguration=null;.)
		FOR component_specification<out componentSpec>
			[binding_indication<out indication> SEMICOLON]
			[block_configuration<out blockConfiguration>]
		END_TOKEN FOR SEMICOLON
		(.componentConfig=new ComponentConfiguration(componentSpec,toOption(indication),toOption(blockConfiguration));.) 
		.	
			
package_declaration<out PackageDeclaration packageDecl> = 
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); .)
		PACKAGE identifier<out Identifier start_identifier> IS
			{package_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
		END_TOKEN [PACKAGE] [unused_identifier] SEMICOLON
		(.packageDecl=new PackageDeclaration(start_identifier,declarativeItems.toList());.)
		.
		
package_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| component_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| disconnection_specification<out item> 
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.

package_body<out PackageBodyDeclaration packageBody> =
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();.)
		PACKAGE BODY identifier<out Identifier start_identifier> IS
			{package_body_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)}
		END_TOKEN [PACKAGE BODY] [unused_identifier] SEMICOLON
		(.packageBody = new PackageBodyDeclaration(start_identifier,declarativeItems.toList());.)
		.
    
package_body_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| signal_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| use_clause<out item>
		| attribute_specification<out item> //attribute_specification is not part of VHDL 2002, added to compile ghdl math_real-body.vhd
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item> 
		)
		.
		
designator<out Identifier identifier> =
	  (.identifier = null;.)
	  (
	  identifier<out identifier>
	  | STRING_LITERAL (.identifier=toIdentifier(t);.) //STRING_LITERAL is a operator symbol
	  )
	  .
	  
subprogram_specification<out SubProgramDeclaration decl> =
			(.Position pos=toPosition(la);Identifier designator=null;InterfaceList list=null;decl=null;.)
			(
			PROCEDURE designator<out designator> [LPAREN parameter_interface_list_procedure<out list> RPAREN] 
			(.decl=new ProcedureDeclaration(pos,designator,toOption(list));.)
			| (.boolean pure=true;.)[PURE | IMPURE(.pure=false;.)] FUNCTION designator<out designator> [LPAREN parameter_interface_list_function<out list> RPAREN] RETURN type_mark<out SelectedName returnType>
			(.decl=new FunctionDeclaration(pos,pure,designator,toOption(list),returnType);.)
			)
			.	

subprogram_declartion_or_body<out DeclarativeItem declOrBody> =
		(.SubProgramDefinition subProgramDef=null;.)
		subprogram_specification<out SubProgramDeclaration decl> [subprogram_body<out subProgramDef,decl>] SEMICOLON
		(. if (subProgramDef!=null) declOrBody=subProgramDef; else declOrBody=decl;.)	
		.
		
subprogram_declaration<out DeclarativeItem subprogramDecl> =
	subprogram_specification<out subprogramDecl> SEMICOLON
	.
	
subprogram_body<out SubProgramDefinition subProgramDef,SubProgramDeclaration subprogramDecl> =
		(. MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); .)
		IS
			{subprogram_declarative_item<out DeclarativeItem item>(. declarativeItems.append(item); .)} 
		BEGIN
			sequential_statement_list<out Seq<.SequentialStatement.> sequentialStatements>
		END_TOKEN [PROCEDURE | FUNCTION] [designator<out Identifier unused>]
		(.			
			if (subprogramDecl instanceof ProcedureDeclaration){
				ProcedureDeclaration procDecl = (ProcedureDeclaration)subprogramDecl;
				subProgramDef=new ProcedureDefinition(subprogramDecl.position(),procDecl.identifier(),procDecl.parameterInterfaceList(),declarativeItems.toList(),sequentialStatements);
			}else {
				FunctionDeclaration funcDecl=(FunctionDeclaration)subprogramDecl;
				subProgramDef=new FunctionDefinition(subprogramDecl.position(),funcDecl.pure(),funcDecl.identifier(),funcDecl.parameterInterfaceList(),funcDecl.returnType(),declarativeItems.toList(),sequentialStatements);
			}
		.)
		.
		
subprogram_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| use_clause<out item> 
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		) 
		.

type_declaration<out AbstractTypeDeclaration typeDecl> =
		(.Position pos=toPosition(la);typeDecl=null;.)
		TYPE identifier<out Identifier id> (
		IS type_definition<out typeDecl,id,pos> SEMICOLON
		| SEMICOLON (.typeDecl=new IncompleteTypeDeclaration(pos,id);.) 
		)
		.

type_definition<out AbstractTypeDeclaration typeDef,Identifier id,Position pos> =
		(.typeDef=null;.)
		(
		enumeration_type_definition<out typeDef,id,pos> 
		| IF(IsPhysicalType()) physical_type_definition<out typeDef,id,pos>
		| integer_or_floating_point_type_definition<out typeDef,id,pos>
		| array_type_definition<out typeDef,id,pos>
		| record_type_definition<out typeDef,id,pos>
		| access_type_definition<out typeDef,id,pos> 
		| file_type_definition<out typeDef,id,pos>
		| IF(scanner.Peek().kind==_BODY)protected_type_body<out typeDef,id,pos> 
		| protected_type_declaration<out typeDef,id,pos>
		)
		.

	
constant_declaration <out ConstantDeclaration constantDecl> =
		(.Position pos=toPosition(la);Expression expr=null;.)
		CONSTANT identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] SEMICOLON 
		(.constantDecl=new ConstantDeclaration(pos,list,subType,toOption(expr));.)
		.
	
signal_declaration<out SignalDeclaration signalDecl> =
		(.Position pos=toPosition(la);Expression expr=null;boolean reg=false,bus=false;.)
		SIGNAL identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType> [REGISTER(.reg=true;.)|BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>] SEMICOLON
		(.
			Option<scala.Enumeration.Value> signalType=null;
				if(reg) signalType=new Some(SignalType.REGISTER());
				else if (bus) signalType=new Some(SignalType.BUS());
				else signalType=scala.None$.MODULE$;
			signalDecl=new SignalDeclaration(pos,list,subType,signalType,toOption(expr));
		.)
		.
		
variable_declaration<out VariableDeclaration varDecl> =
		(.Position pos=toPosition(la);Expression expr=null;boolean shared=false;.)
		[SHARED(.shared=true;.)] VARIABLE identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] SEMICOLON
		(.varDecl=new VariableDeclaration(pos,shared,list,subType,toOption(expr));.)
		.
	
file_declaration<out FileDeclaration fileDecl> =
		(.Position pos=toPosition(la);Expression file_open_kind_expression=null,file_logical_name=null;.)
		FILE identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType> [[OPEN expression<out file_open_kind_expression>] IS expression<out file_logical_name>] SEMICOLON
		(.fileDecl=new FileDeclaration(pos,list,subType,toOption(file_open_kind_expression),toOption(file_logical_name));.)
		.
	
alias_declaration<out AliasDeclaration aliasDecl> =
		(.Position pos=toPosition(la);Signature signature=null;SubTypeIndication subType=null;.)
		ALIAS alias_designator<out Identifier designator> [COLON subtype_indication<out subType>] IS name<out Name name> [signature<out signature>] SEMICOLON
		(.aliasDecl=new AliasDeclaration(pos,designator,toOption(subType),name,toOption(signature));.)
		.

alias_designator<out Identifier identifier> =
		(.identifier=null;.)
		(identifier<out identifier> 
		|CHARACTER_LITERAL(.identifier=toIdentifier(t);.)
		|STRING_LITERAL(.identifier=toIdentifier(t);.)
		).	
	
component_declaration<out ComponentDeclaration componentDecl> =
		(.Position pos=toPosition(la);InterfaceList genericClause=null,portClause=null;.)
		COMPONENT identifier<out Identifier start_identifier> [IS]
			[generic_clause<out genericClause>]
			[port_clause<out portClause>]
		END_TOKEN COMPONENT [unused_identifier] SEMICOLON
		(.componentDecl=new ComponentDeclaration(pos,start_identifier,toOption(genericClause),toOption(portClause));.)
		.

attribute_declaration<out AttributeDeclaration attributeDecl> =
		(.Position pos=toPosition(la);.)
		ATTRIBUTE identifier<out Identifier identifier> COLON type_mark<out SelectedName type> SEMICOLON 
		(.attributeDecl=new AttributeDeclaration(pos,identifier,type);.)
		.
	
attribute_specification<out AttributeSpecification node> =
		(.Position pos=toPosition(la);Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> nameList=null;.)
		ATTRIBUTE identifier<out Identifier identifier> OF entity_name_list<out nameList> COLON entity_class<out scala.Enumeration.Value entityClass> IS expression<out Expression expr> SEMICOLON 
		(.node=new AttributeSpecification(pos,identifier,nameList,entityClass,expr);.)
		.
		
entity_designator<out Tuple2<Identifier,Option<Signature>> designator> =
		(. Identifier identifier=null; Signature signature=null;.)
		(identifier<out identifier>
		|CHARACTER_LITERAL(.identifier=toIdentifier(t);.)
		|STRING_LITERAL(.identifier=toIdentifier(t);.)
		) [signature<out signature>]
		(.designator=new Tuple2<Identifier,Option<Signature>>(identifier,new Option<Signature>(signature)); .)
		.
	
entity_name_list<out Either<Seq<Tuple2<Identifier,Option<Signature>>>,Identifier> list> =
		(. 
		   MyListBuffer<Tuple2<Identifier,Option<Signature>>> elements=new MyListBuffer<Tuple2<Identifier,Option<Signature>>>();
		   Tuple2<Identifier,Option<Signature>> designator=null;
		   list=null;
		.)
		(
		entity_designator<out designator> (.elements.append(designator); .) {COMMA entity_designator<out designator> (.elements.append(designator);.)} (.list=new Left(elements.toList());.)
		| OTHERS (.list=new Right(toIdentifier(t));.)
		| ALL (.list=new Right(toIdentifier(t));.)
		)
		.

entity_class<out scala.Enumeration.Value entityClass> =
		(.entityClass=null;.)
		(
		ENTITY (.entityClass=EntityClass.ENTITY();.)
		| ARCHITECTURE (.entityClass=EntityClass.ARCHITECTURE();.)
		| CONFIGURATION (.entityClass=EntityClass.CONFIGURATION();.)
		| PACKAGE (.entityClass=EntityClass.PACKAGE();.)
		| PROCEDURE (.entityClass=EntityClass.PROCEDURE();.)
		| FUNCTION (.entityClass=EntityClass.FUNCTION();.)
		| TYPE (.entityClass=EntityClass.TYPE();.)
		| SUBTYPE (.entityClass=EntityClass.SUBTYPE();.)
		| CONSTANT (.entityClass=EntityClass.CONSTANT();.)
		| SIGNAL (.entityClass=EntityClass.SIGNAL();.)
		| VARIABLE (.entityClass=EntityClass.VARIABLE();.)
		| FILE (.entityClass=EntityClass.FILE();.)
		| COMPONENT (.entityClass=EntityClass.COMPONENT();.)
		| LABEL (.entityClass=EntityClass.LABEL();.)
		| LITERAL (.entityClass=EntityClass.LITERAL();.)
		| UNITS (.entityClass=EntityClass.UNITS();.)
		| GROUP (.entityClass=EntityClass.GROUP();.)
		)
		.
		
configuration_specification<out ConfigurationSpecification configSpec> =
		(.Position pos=toPosition(la);.)
		FOR component_specification<out componentSpec>
			binding_indication<out indication> SEMICOLON
		(.configSpec= new ConfigurationSpecification(pos);.)
		.
		
instantiation_list<out Either<Seq<Identifier>,Identifier> list> =
	  (.list=null;.)
	  (
	  identifier_list<out Seq<.Identifier.> identifierList> (.list=new Left(list);.)
		| OTHERS (.list=new Right(toIdentifier(t));.)
		| ALL (.list=new Right(toIdentifier(t));.)
	  )
		.		

component_specification<out Object spec> = 
		instantiation_list<out Object list> COLON selected_name<out SelectedName name>
		.

entity_aspect =
		ENTITY selected_name<out SelectedName entity_name> [LPAREN identifier<out Identifier architecture_identifier> RPAREN] 
		| CONFIGURATION  selected_name<out SelectedName configuration_name> 
		| OPEN 
		.
		
binding_indication<out Object indication> =
		[USE entity_aspect]
		[generic_map_aspect<out AssociationList genericMap>]
		[port_map_aspect<out AssociationList portMap>]
		.

disconnection_specification<out DisconnectionSpecification disconnectSpec> =
		(.Position pos=toPosition(la);Identifier id=null;Seq<SelectedName> list=null;.)
		DISCONNECT (selected_name_list<out list> | OTHERS(.id=toIdentifier(t);.) | ALL (.id=toIdentifier(t);.)) COLON type_mark<out SelectedName type> AFTER expression<out Expression expr> SEMICOLON
		(.disconnectSpec= new DisconnectionSpecification(pos,id==null?new Left(list):new Right(id),type,expr);.)
		.

entity_class_entry<out GroupTemplateDeclaration.Element entry> =
		(.boolean box=false;.)
	  	entity_class<out scala.Enumeration.Value  entityClass> [BOX(.box=true;.)]
		(.entry = new GroupTemplateDeclaration.Element(entityClass,box);.)
		.
		
group_template_declaration<out GroupTemplateDeclaration groupTemplateDecl> =
		(.
		  Position pos=toPosition(la);
		  MyListBuffer<GroupTemplateDeclaration.Element> elements=new MyListBuffer<GroupTemplateDeclaration.Element>(); 
	    .)
		GROUP identifier<out Identifier identifier> IS LPAREN entity_class_entry<out GroupTemplateDeclaration.Element entry> (.elements.append(entry);.) {COMMA entity_class_entry<out entry> (.elements.append(entry);.)}  RPAREN SEMICOLON
		(.groupTemplateDecl=new GroupTemplateDeclaration(pos,identifier,elements.toList());.)
		.
		
		
group_declaration<out GroupDeclaration groupDecl> =
		(.Position pos=toPosition(la);Seq<Either<Name,Identifier>> list=null;.)		
		GROUP identifier<out Identifier identifier> COLON selected_name<out SelectedName selectedName> LPAREN group_constituent_list<out list> RPAREN SEMICOLON
		(.groupDecl=new GroupDeclaration(pos,identifier,selectedName,list);.)
		.
	
group_constituent<out Either<Name,Identifier> constituent> =
	(.constituent=null;.)
	(
       name<out Name name> (.constituent=new Left(name);.)
    |  CHARACTER_LITERAL (.constituent=new Right(toIdentifier(t));.)
    )
    .

group_constituent_list<out Seq<Either<Name,Identifier>> list> =
		(. 
		   MyListBuffer<Either<Name,Identifier>> elements=new MyListBuffer<Either<Name,Identifier>>(); 
		   Either<Name,Identifier> element=null;
		.)
		group_constituent<out element> (.elements.append(element); .) {COMMA group_constituent<out element> (.elements.append(element);.)}
		(.list=elements.toList();.)
    	.
    
use_clause<out UseClause useClause> =
		(.Position pos=toPosition(la);.)
		USE selected_name_list<out Seq<.SelectedName.> list> SEMICOLON
		(.useClause=new UseClause(pos,list);.)
		.

enumeration_literal<out Identifier identifier> =
		(.identifier=null;.)
		(
		identifier<out identifier>
		|CHARACTER_LITERAL (.identifier=toIdentifier(t);.)
		)
		.
	
enumeration_type_definition<out EnumerationTypeDefinition enumTypeDef,Identifier id,Position pos> =
		(. 
		   MyListBuffer<Identifier> elements=new MyListBuffer<Identifier>(); 
		   Identifier element=null;
		.)
		LPAREN enumeration_literal<out element> (.elements.append(element);.){COMMA enumeration_literal<out element> (.elements.append(element);.)} RPAREN
		(.enumTypeDef=new EnumerationTypeDefinition(pos,id,elements.toList());.)
		.
	
integer_or_floating_point_type_definition<out IntegerOrFloatingPointTypeDefinition intOrFloat,Identifier id,Position pos> =
		RANGE range<out Range range>
		(.intOrFloat=new IntegerOrFloatingPointTypeDefinition(pos,id,range);.)
		.
			
physical_type_definition<out PhysicalTypeDefinition physicalTypeDef, Identifier id,Position pos> =
		(. MyListBuffer<PhysicalTypeDefinition.Element> elements=new MyListBuffer<PhysicalTypeDefinition.Element>(); .)
		RANGE range<out Range range>
		UNITS
			identifier<out Identifier baseIdentifier> SEMICOLON
			{
			identifier<out Identifier identifier> EQ physical_literal<out literal> SEMICOLON 
			(.elements.append(new PhysicalTypeDefinition.Element(identifier,literal));.)
			}
		END_TOKEN UNITS [unused_identifier]
		(.physicalTypeDef=new PhysicalTypeDefinition(pos,id,range,baseIdentifier,elements.toList());.)
		.		

index_subtype_definition<out SelectedName typeMark> =
	 	type_mark<out typeMark> RANGE BOX
		.
				
array_type_definition<out AbstractArrayTypeDefinition arrayTypeDef,Identifier id,Position pos> = 
		(. MyListBuffer<SelectedName> unConstraintList=new MyListBuffer<SelectedName>();
		   SubTypeIndication subType=null;
		   Seq<DiscreteRange> ranges =null;
		   SelectedName type=null;
		.)
		ARRAY (
		IF(IsIndexSubtypeDefinition()) LPAREN index_subtype_definition<out type> (.unConstraintList.append(type);.) {COMMA index_subtype_definition<out type> (.unConstraintList.append(type);.)} RPAREN OF subtype_indication<out subType>
		| index_constraint<out ranges> OF subtype_indication<out subType>
		)
		(.
			if (unConstraintList.isEmpty()) arrayTypeDef=new ConstrainedArrayTypeDefinition(pos,id,ranges,subType);
			else arrayTypeDef=new UnconstrainedArrayTypeDefinition(pos,id,unConstraintList.toList(),subType);
		.)
		.
		
record_type_definition<out RecordTypeDefinition recordTypeDef,Identifier id,Position pos> =
		(. MyListBuffer<RecordTypeDefinition.Element> elements=new MyListBuffer<RecordTypeDefinition.Element>(); .)
		RECORD 
			{
			identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType> SEMICOLON
			(.elements.append(new RecordTypeDefinition.Element(list, subType));.)
			} //TODO + not *
		END_TOKEN RECORD [unused_identifier]
		(.recordTypeDef=new RecordTypeDefinition(pos,id,elements.toList());.)
		.

access_type_definition<out AccessTypeDefinition accessTypeDef,Identifier id,Position pos> =
		ACCESS subtype_indication<out SubTypeIndication subType> 
		(.accessTypeDef=new AccessTypeDefinition(pos,id,subType);.)
		.
	
file_type_definition<out FileTypeDefinition fileTypeDef,Identifier id,Position pos> =
		FILE OF type_mark<out SelectedName type> 
		(.fileTypeDef=new FileTypeDefinition(pos,id,type);.)
		.
		
protected_type_declaration<out ProtectedTypeDeclaration protectedTypeDecl,Identifier id,Position pos> =
		(. MyListBuffer<DeclarativeItem> items=new MyListBuffer<DeclarativeItem>(); .)
		PROTECTED
			{protected_type_declarative_item<out DeclarativeItem item>(.items.append(item);.)}
		END_TOKEN PROTECTED [unused_identifier]
		(.protectedTypeDecl=new ProtectedTypeDeclaration(pos,id,items.toList());.)
		.
				
protected_type_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| attribute_specification<out item> 
		| use_clause<out item>
		)
		.

protected_type_body<out ProtectedTypeBodyDeclaration protectedTypeBody,Identifier id,Position pos> =
		(. MyListBuffer<DeclarativeItem> items=new MyListBuffer<DeclarativeItem>(); .)
		PROTECTED BODY
			{protected_type_body_declarative_item<out DeclarativeItem item>(.items.append(item);.)}
		END_TOKEN PROTECTED BODY [unused_identifier]
		(.protectedTypeBody=new ProtectedTypeBodyDeclaration(pos,id,items.toList());.)
		.

protected_type_body_declarative_item<out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item>
		| variable_declaration<out item>
		| file_declaration<out item>
		| alias_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item> 
		)
		.
		
subtype_declaration<out SubTypeDeclaration subTypeDecl> =
		(.Position pos=toPosition(la);.)
		SUBTYPE identifier<out Identifier identifier> IS subtype_indication<out SubTypeIndication subType> SEMICOLON
		(.subTypeDecl=new SubTypeDeclaration(pos,identifier,subType);.)
		.
		
subtype_indication<out SubTypeIndication subType> =
		(.Object constraint=null;SelectedName n2=null;.)
		selected_name<out SelectedName n1> [selected_name<out n2>] [constraint<out constraint>]
		(.
			if (n2!=null) subType=new SubTypeIndication(new Some(n1),n2,toOption(constraint));
			else subType=new SubTypeIndication(scala.None$.MODULE$,n1,toOption(constraint));
		.)
		.
  
direction<out scala.Enumeration.Value rangeDirection> =
		(.rangeDirection=null;.)
		(
		TO_TOKEN (.rangeDirection=Range.To();.)
		|DOWNTO (.rangeDirection=Range.Downto();.)
		)
		.

range_constraint<out Range rangeContraint> =
		RANGE range<out rangeContraint>
		.

index_constraint<out Seq<DiscreteRange> ranges> =
		(. 
		   MyListBuffer<DiscreteRange> list=new MyListBuffer<DiscreteRange>();
		   DiscreteRange discreteRange=null;
		.)
		LPAREN discrete_range<out discreteRange> (.list.append(discreteRange);.) {COMMA  discrete_range<out discreteRange> (.list.append(discreteRange);.)} RPAREN
		(.ranges = list.toList();.)
		.
		
range<out Range range> =
		(
		//TODO(simple_expression direction)=> from=simple_expression direction to=simple_expression 
		//| name
		)
		(.range =new Range(from.simpleExpr,direction.rangeDirection,to.simpleExpr,name.name_);.)
		.

constraint<out Either<Range,Seq<DiscreteRange>> constraint> =
		(.constraint=null;.)
		(
		range_constraint<out Range rangeContraint> (.constraint = new Left(rangeContraint);.)
		| index_constraint<out Seq<.DiscreteRange.> ranges> (.constraint = new Right(ranges);.)
		)
		.

discrete_range<out DiscreteRange discreteRange> =
		//TODO(simple_expression direction)=>r=range {$discreteRange=new DiscreteRange(new Left($r.range_))}
		//|(selected_name range_constraint)=>discrete_subtype_indication=subtype_indication {$discreteRange=new DiscreteRange(new Right($discrete_subtype_indication.subType))}
		 range<out Range range> (.discreteRange=new DiscreteRange(new Left(range));.)
		.
		
type_mark<out SelectedName typeName> =
		selected_name<out typeName> // could be type_name or subtype_name;
		.
		
architecture_statement_list<out Seq<ConcurrentStatement> list> =
(.
	MyListBuffer<ConcurrentStatement> statementList=new MyListBuffer<ConcurrentStatement>();
.)
	  {architecture_statement<out ConcurrentStatement stmt> (.statementList.append(stmt);.)}
	  (.list=statementList.toList();.)
	  .

architecture_statement<out ConcurrentStatement concurrentStmt> =
		(.
		  concurrentStmt=null;
		  Identifier label=null;
		.)
		(
		  label_colon<out label> (
			//TODO (architecture_statement_with_label[null])=>architecture_statement_with_label[label] {$stmt=$architecture_statement_with_label.stmt}
			architecture_statement_optional_label<out concurrentStmt,label>
			)
		| architecture_statement_optional_label<out concurrentStmt,label>
		)
		.

architecture_statement_with_label<out ConcurrentStatement concurrentStmt, Identifier label> =
		(.concurrentStmt=null;.)
		(
		component_instantiation_statement<out concurrentStmt,label>
		| block_statement<out concurrentStmt,label>
		| generate_statement<out concurrentStmt,label>
		)
		.
				
architecture_statement_optional_label<out ConcurrentStatement concurrentStmt, Identifier label> =
		(.concurrentStmt=null;boolean postponed=false;.)
		[POSTPONED(.postponed=true;.)] 
		(process_statement<out concurrentStmt,label,postponed>
		| concurrent_assertion_statement<out concurrentStmt,label,postponed>
		| IF(IsConcurrentSignalSssignmentStatement())concurrent_signal_assignment_statement<out concurrentStmt,label,postponed>
		| concurrent_procedure_call_statement<out concurrentStmt,label,postponed>
		)
		.		

generic_map_aspect<out AssociationList associationList> =
		GENERIC MAP LPAREN association_list<out associationList> RPAREN
		.
		
port_map_aspect<out AssociationList associationList> =
		PORT MAP LPAREN association_list<out associationList> RPAREN
		.
					
block_statement<out BlockStatement blockStmt, Identifier label> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>(); 
		   Expression guard_expression=null;
		   InterfaceList genericClause=null,portClause=null;
		   AssociationList genericMap=null,portMap=null;
		.)
		BLOCK [LPAREN expression<out guard_expression> RPAREN] [IS]
			[generic_clause<out genericClause> [generic_map_aspect<out genericMap> SEMICOLON]]
			[port_clause<out portClause> [port_map_aspect<out portMap> SEMICOLON]]
			{block_declarative_item<out DeclarativeItem item>(. declarativeItems.append(item);.)}
		BEGIN
			architecture_statement_list<out Seq<.ConcurrentStatement.> statementList>
		END_TOKEN BLOCK [unused_identifier] SEMICOLON 
		(. blockStmt=new BlockStatement(pos,toOption(label),toOption(guard_expression),toOption(genericClause),toOption(genericMap),toOption(portClause),toOption(portMap),declarativeItems.toList(),statementList);.)
		.
				
block_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item>
		| subtype_declaration<out item>
		| constant_declaration<out item> 
		| signal_declaration<out item> 
		| variable_declaration<out item>
		| file_declaration<out item> 
		| alias_declaration<out item>
		| component_declaration<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| configuration_specification<out item> 
		| disconnection_specification<out item>
		| use_clause<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item>
		| group_declaration<out item>
		)
		.
		
process_statement<out ProcessStatement processStmt,Identifier label,boolean postponed> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();
		   Seq<Name> name_list=null;
		.)
		PROCESS [LPAREN name_list<out name_list> RPAREN] [IS]
			{process_declarative_item<out DeclarativeItem item> (.declarativeItems.append(item);.)}
		BEGIN
			sequential_statement_list<out Seq<.SequentialStatement.> sequentialStatements>
		END_TOKEN [POSTPONED] PROCESS [unused_identifier] SEMICOLON
		(.processStmt=new ProcessStatement(pos,toOption(label),postponed,toOption(name_list),declarativeItems.toList(),sequentialStatements);.)
		.
		
process_declarative_item <out DeclarativeItem item> =
		(.item=null;.)
		(
		subprogram_declartion_or_body<out item>
		| type_declaration<out item> 
		| subtype_declaration<out item> 
		| constant_declaration<out item>
		| variable_declaration<out item> 
		| file_declaration<out item>
		| alias_declaration<out item> 
		| use_clause<out item>
		| IF(IsAttributeDeclaration())attribute_declaration<out item>
		| attribute_specification<out item>
		| IF(IsGroupTemplate())group_template_declaration<out item> 
		| group_declaration<out item>
		)
		.
		
concurrent_procedure_call_statement<out ConcurrentProcedureCallStatement procedureCallStmt, Identifier label,boolean postponed> =
		(.AssociationList paramterList=null;.)
		selected_name<out SelectedName procedure_name> [LPAREN association_list<out paramterList>  RPAREN] SEMICOLON
		(.procedureCallStmt=new ConcurrentProcedureCallStatement(toOption(label),postponed,procedure_name,toOption(paramterList));.)
		.
		
concurrent_assertion_statement<out ConcurrentAssertionStatement assertStmt, Identifier label,boolean postponed> =
		(.Position pos=toPosition(la);Expression report_expression=null,severity_expression=null;.)
		ASSERT condition<out Expression expr>  [REPORT expression<out report_expression>] [SEVERITY expression<out severity_expression>] SEMICOLON
		(.assertStmt=new ConcurrentAssertionStatement(pos,toOption(label),postponed,expr,toOption(report_expression),toOption(severity_expression));.)
		.
							
concurrent_signal_assignment_statement<out ConcurrentSignalAssignmentStatement signalAssignmentStatement, Identifier label,boolean postponed> =
		 conditional_signal_assignment<out signalAssignmentStatement,label,postponed>
		|selected_signal_assignment<out signalAssignmentStatement,label,postponed>
		.

conditional_signal_assignment<out ConcurrentConditionalSignalAssignment signalAssignment, Identifier label,boolean postponed> =
		(. 
		   MyListBuffer<ConcurrentConditionalSignalAssignment.When> elements=new MyListBuffer<ConcurrentConditionalSignalAssignment.When>();
		   boolean guarded=false;
		   DelayMechanism delay=null;
		.)
		target<out Target target> LEQ (.Position pos=toPosition(t);.) [GUARDED(.guarded=true;.)] [delay_mechanism<out delay>]
  			conditional_waveforms<elements>
			SEMICOLON
		(.signalAssignment=new ConcurrentConditionalSignalAssignment(pos,toOption(label),postponed,target,guarded,toOption(delay),elements.toList());.)
		.

//TODO 
conditional_waveforms<MyListBuffer elements> =
		(.Expression expr=null;.)
       waveform<out Waveform waveform> [ WHEN condition<out expr> [ ELSE conditional_waveforms<elements> ] ] (.elements.prepend(new ConcurrentConditionalSignalAssignment.When(waveform,expr));.)
       .
 
selected_waveform<out ConcurrentSelectedSignalAssignment.When whenClause> =
 		waveform<out Waveform waveform> WHEN choices<out Choices choices> (.whenClause = new ConcurrentSelectedSignalAssignment.When(waveform,choices);.)
 		.  
 		
selected_signal_assignment<out ConcurrentSelectedSignalAssignment signalAssignment,Identifier label,boolean postponed> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<ConcurrentSelectedSignalAssignment.When> elements=new MyListBuffer<ConcurrentSelectedSignalAssignment.When>(); 
		   boolean guarded=false;
		   ConcurrentSelectedSignalAssignment.When when=null;
		   DelayMechanism delay=null;
		.)
		WITH expression<out Expression expr> SELECT
			target<out Target target> LEQ [GUARDED(.guarded=true;.)] [delay_mechanism<out delay>] 
			selected_waveform<out when> (.elements.append(when);.){COMMA selected_waveform<out when>(.elements.append(when);.)} SEMICOLON
			(.signalAssignment=new ConcurrentSelectedSignalAssignment(pos,toOption(label),postponed,expr,target,guarded,toOption(delay),elements.toList());.)
			.
			
target<out Target target> =
		(.target=null;.)
		(
   		name<out Name name> (.target = new Target(new Left(name));.)
  		| aggregate<out Aggregate aggregate> (.target = new Target(new Right(aggregate));.)
  		)
  		.
  		
component_instantiation_statement<out ComponentInstantiationStatement stmt, Identifier label> =
(.
	ComponentInstantiationStatement.ComponentType.Value componentType =null;
	AssociationList genericMap=null,portMap=null;
	Token firstToken=la;
.)
		/*( COMPONENT? n=selected_name {componentType=ComponentInstantiationStatement.ComponentType.COMPONENT }
		  | ENTITY n=selected_name (LPAREN architecture_identifier=identifier RPAREN)? {componentType=ComponentInstantiationStatement.ComponentType.ENTITY}
		  | CONFIGURATION n=selected_name {componentType=ComponentInstantiationStatement.ComponentType.CONFIGURATION})
		TODO*/
		[generic_map_aspect<out genericMap>]
		[port_map_aspect<out portMap>] SEMICOLON
		(.stmt=new ComponentInstantiationStatement(toPosition(firstToken),label,componentType,$n.name_,$architecture_identifier.id,genericMap,portMap);.)
		.
		
generate_statement<out ConcurrentStatement generateStmt, Identifier label> =
		(.generateStmt=null;.)
		(
		for_generate_statement<out generateStmt, label>
		| if_generate_statement<out generateStmt, label>
		)
		.
	
for_generate_statement<out ForGenerateStatement forGenerateStmt, Identifier label> =
		(.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
		FOR identifier<out Identifier loopIdentifier> IN discrete_range<out DiscreteRange discreteRange> GENERATE
			generate_statement_body<out body>
		END_TOKEN GENERATE [unused_identifier] SEMICOLON
		(.forGenerateStmt=new ForGenerateStatement(pos,toOption(label),loopIdentifier,discreteRange,body._1,body._2);.)
		.
		
if_generate_statement<out IfGenerateStatement ifGenerateStmt, Identifier label> =
		(.Position pos=toPosition(la);Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> body=null;.)
		IF_TOKEN condition<out Expression expr> GENERATE
			generate_statement_body<out body>
		END_TOKEN GENERATE [unused_identifier] SEMICOLON
		(.ifGenerateStmt=new IfGenerateStatement(pos,toOption(label),expr,body._1,body._2);.)
		.
		
generate_statement_body<out Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>> statementList> =
(.
	MyListBuffer<DeclarativeItem> declarativeItems=new MyListBuffer<DeclarativeItem>();
.)
		[{block_declarative_item<out DeclarativeItem item>(.declarativeItems.append(item);.)} 
	    BEGIN]
	   	architecture_statement_list<out Seq<.ConcurrentStatement.> concurrentStatements>
	   	(.
	   		statementList=new Tuple2<Seq<DeclarativeItem>,Seq<ConcurrentStatement>>(declarativeItems,concurrentStatements);
	   	.)
	   	.

sequential_statement_list<out Seq<SequentialStatement> list> =
(.
	MyListBuffer<SequentialStatement> tmpList=new MyListBuffer<SequentialStatement>();
.)
		{sequential_statement<out SequentialStatement stmt>(.tmpList.append(stmt);.)}
		(.list=tmpList.toList();.)
		.

sequential_statement<out SequentialStatement sequentialStatement> =
		(.sequentialStatement=null;Identifier label=null;.)
		(
		[label_colon<out label>] 
		(wait_statement<out sequentialStatement,label>
		| assertion_statement<out sequentialStatement,label>
		| report_statement<out sequentialStatement,label>
		| if_statement<out sequentialStatement,label>
		| case_statement<out sequentialStatement,label>
		| loop_statement<out sequentialStatement,label>
		| next_statement<out sequentialStatement,label>
		| exit_statement<out sequentialStatement,label>
		| return_statement<out sequentialStatement,label>
		| null_statement<out sequentialStatement,label>
		| IF(IsAssignmentStatement())signal_or_variable_assignment_statement<out sequentialStatement,label>
		| procedure_call_statement<out sequentialStatement,label>
		)
		)
		.
	
wait_statement<out WaitStatement waitStmt, Identifier label> =	
		(.Position pos=toPosition(la);Expression untilExpr=null,forExpression=null;Seq<Name> name_list=null;.)
		WAIT [ON name_list<out name_list>] [UNTIL condition<out untilExpr>] [FOR expression<out forExpression>] SEMICOLON
		(.waitStmt=new WaitStatement(pos,toOption(label),toOption(name_list),toOption(untilExpr),toOption(forExpression));.)
		.
				
assertion_statement<out AssertStatement assertStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression report_expression=null, severity_expression= null;.)
		ASSERT condition<out Expression expr> [REPORT expression<out report_expression>] [SEVERITY expression<out severity_expression>] SEMICOLON
		(.assertStmt=new AssertStatement(pos,toOption(label),expr,toOption(report_expression),toOption(severity_expression));.)
		.
			     
report_statement<out ReportStatement reportStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression severity_expression=null;.)
		REPORT expression<out Expression report_expression> [SEVERITY expression<out severity_expression>] SEMICOLON
		(.reportStmt=new ReportStatement(pos,toOption(label),report_expression,toOption(severity_expression));.)
		.	

signal_or_variable_assignment_statement<out SequentialStatement statement,Identifier label> =
		(.statement=null;.)
		target<out Target target> (
			signal_assignment_statement<out statement,label,target>
			| variable_assignment_statement<out statement,label,target>
		)
		.
		
variable_assignment_statement<out VariableAssignmentStatement varAssignStmt,Identifier label,Target target> =
		VAR_ASSIGN (.Position pos=toPosition(t);.) expression<out Expression expr> SEMICOLON
		(.varAssignStmt=new SimpleVariableAssignmentStatement(pos,toOption(label),target,expr);.)
		.
		
signal_assignment_statement<out SignalAssignmentStatement signalAssignStmt, Identifier label,Target target> =
		(.DelayMechanism delay=null;.)
		LEQ (.Position pos=toPosition(t);.)[delay_mechanism<out delay>] waveform<out Waveform waveform> SEMICOLON
		(.signalAssignStmt=new SimpleSignalAssignmentStatement(pos,toOption(label),target,toOption(delay),waveform);.)
		.
					
delay_mechanism<out DelayMechanism mechanism> =
		(.Expression time_expression=null;.)
		(
		TRANSPORT 
		| [REJECT expression<out time_expression>] INERTIAL
		)
		(.
			if (time_expression==null) mechanism=new DelayMechanism(DelayMechanism.TRANSPORT(),scala.None$.MODULE$);
			else mechanism=new DelayMechanism(DelayMechanism.INERTIAL(),toOption(time_expression));
		.)
		.

waveform_element<out Waveform.Element element> =
	(.Expression time_expression=null;.)
 	expression<out Expression value_expression> [AFTER expression<out time_expression>]  
 	(.element= new Waveform.Element(value_expression,toOption(time_expression));.)
 	.
	
waveform<out Waveform waveForm> =
		(.MyListBuffer<Waveform.Element> elements=new MyListBuffer<Waveform.Element>();.)
		(
		waveform_element<out Waveform.Element element>(.elements.append(element);.) {COMMA waveform_element<out element>(.elements.append(element);.)}
		| UNAFFECTED 
		)
		(.waveForm=new Waveform(elements.toList());.)
		.
				
procedure_call_statement<out ProcedureCallStatement procedureCallStmt, Identifier label> =
		(.AssociationList paramterList=null;.)
		selected_name<out SelectedName procedure_name> [LPAREN association_list<out paramterList> RPAREN] SEMICOLON
		(.procedureCallStmt=new ProcedureCallStatement(toOption(label),procedure_name,toOption(paramterList));.)
		.
	
if_statement<out IfStatement ifStmt, Identifier label> =
		(.
		   Position pos=toPosition(la); 
		   MyListBuffer<IfStatement.IfThenPart> ifList=new MyListBuffer<IfStatement.IfThenPart>(); 
		   Seq<SequentialStatement> sequentialStatements = null;
		   Seq<SequentialStatement> else_sequential_statement = null;
		.)
		IF_TOKEN condition<out Expression if_condition> THEN
			sequential_statement_list<out sequentialStatements> (.ifList.append(new IfStatement.IfThenPart(if_condition,sequentialStatements));.)
		{ELSIF condition<out Expression elsif_condition> THEN
			 sequential_statement_list<out sequentialStatements>
			 (.ifList.append(new IfStatement.IfThenPart(elsif_condition,sequentialStatements));.)
			 }
		[ELSE	
			sequential_statement_list<out else_sequential_statement>]
		END_TOKEN IF_TOKEN [unused_identifier] SEMICOLON 
		(.ifStmt=new IfStatement(pos,toOption(label),ifList.toList(),toOption(else_sequential_statement));.)
		.

case_statement<out CaseStatement caseStmt,Identifier label> =
		(. 
		   Position pos=toPosition(la);
		   MyListBuffer<CaseStatement.When> alternatives=new MyListBuffer<CaseStatement.When>(); 
		.)
		CASE expression<out Expression expr> IS
			{WHEN choices<out Choices choices> ARROW sequential_statement_list<out Seq<.SequentialStatement.> sequentialStatements> (.alternatives.append(new CaseStatement.When(choices,sequentialStatements));.)} //TODO + statt *
		END_TOKEN CASE  [unused_identifier] SEMICOLON
		(.caseStmt=new CaseStatement(pos,toOption(label),expr,alternatives.toList());.)
		.

iteration_scheme<out Either<Expression,Tuple2<Identifier,DiscreteRange>> scheme> =
		(.scheme=null;.)
		(
		WHILE condition<out Expression expr> (.scheme=new Left(expr);.)
		| FOR identifier<out Identifier identifier> IN discrete_range<out DiscreteRange discreteRange> (.scheme=new Right(new Tuple2(identifier,discreteRange));.)
		)
		.	
			
loop_statement<out SequentialStatement loopStmt, Identifier label> =
		(.Position pos=toPosition(la);Object stmtType=null;.)
		[iteration_scheme<out stmtType>] LOOP
			sequential_statement_list<out Seq<.SequentialStatement.> sequentialStatements>
		END_TOKEN LOOP [unused_identifier] SEMICOLON
		(.		
			if (stmtType!=null){
				if (stmtType instanceof Left) loopStmt=new WhileStatement(pos,toOption(label),((Left<Expression>)stmtType).a,sequentialStatements);
				//TODO case Right((identifier,discreteRange)) =>new ForStatement(pos,label,identifier,discreteRange,sequentialStatements);
			}else loopStmt=new LoopStatement(pos,toOption(label),sequentialStatements);
		.)
		.

next_statement<out NextStatement nextStmt,Identifier label> =
		(.Position pos=toPosition(la);Identifier identifier=null;Expression expr=null;.)
		NEXT [identifier<out identifier>] [WHEN condition<out expr>] SEMICOLON 
		(.nextStmt=new NextStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
		.

exit_statement<out ExitStatement exitStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression expr=null;Identifier identifier=null;.)
		EXIT [identifier<out identifier>] [WHEN condition<out expr>] SEMICOLON 
		(.exitStmt=new ExitStatement(pos,toOption(label),toOption(identifier),toOption(expr));.)
		.

return_statement<out ReturnStatement returnStmt, Identifier label> =
		(.Position pos=toPosition(la);Expression expr=null;.)
		RETURN [expression<out expr>] SEMICOLON 
		(.returnStmt=new ReturnStatement(pos,toOption(label),toOption(expr));.)
		.
	
null_statement<out NullStatement nullStmt, Identifier label> =
		(.Position pos=toPosition(la);.)
		NULL SEMICOLON
		(.nullStmt=new NullStatement(pos,toOption(label));.)
		.
		
interface_element_procedure<out InterfaceList.AbstractInterfaceElement element> =
		(.element=null;.)
		(
		//(CONSTANT? identifier_list COLON IN?)=> interface_constant_declaration  {$element=$interface_constant_declaration.constElement}
		//TODO | (VARIABLE? identifier_list COLON (OUT|INOUT)?)=>interface_variable_declaration  {$element=$interface_variable_declaration.varElement}
		 interface_signal_declaration_procedure<out element>
		| interface_file_declaration<out element>
		)
		.
		
interface_element_function<out InterfaceList.AbstractInterfaceElement element> =
		(.element=null;.)
		(
	//TODO:	(CONSTANT? identifier_list)=> interface_constant_declaration  {$element=$interface_constant_declaration.constElement}
		 interface_signal_declaration_function<out element>
		| interface_file_declaration<out element>
		)
		.
		
parameter_interface_list_procedure<out InterfaceList list> =
		(.
		  MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>();
		  InterfaceList.AbstractInterfaceElement element=null;
		.)
		interface_element_procedure<out element>(.elements.append(element);.) {SEMICOLON interface_element_procedure<out element> (.elements.append(element);.)} 
		(.list=new InterfaceList(elements.toList());.)
		.
		
parameter_interface_list_function<out InterfaceList list> =
		(.
		  MyListBuffer<InterfaceList.AbstractInterfaceElement> elements=new MyListBuffer<InterfaceList.AbstractInterfaceElement>();
		  InterfaceList.AbstractInterfaceElement element=null;
		.)
		interface_element_function<out element> (.elements.append(element);.) {SEMICOLON interface_element_function<out element> (.elements.append(element);.)} 
		(.list=new InterfaceList(elements.toList());.)
		.
			
interface_constant_declaration<out InterfaceList.InterfaceConstantDeclaration constElement> =
		(.Expression expr=null;.)
		[CONSTANT] identifier_list<out Seq<.Identifier.> list> COLON [IN] subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>] 
		(.constElement=new InterfaceList.InterfaceConstantDeclaration(list,subType,toOption(expr));.)
		.

interface_signal_declaration_procedure<out InterfaceList.InterfaceSignalDeclaration signalElement> =
		(.Expression expr=null;boolean bus=false;scala.Enumeration.Value mode=null;.)
		[SIGNAL] identifier_list<out Seq<.Identifier.> list> COLON [interface_mode<out mode>] subtype_indication<out SubTypeIndication subType> [BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>]
		(.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(mode),subType,bus,toOption(expr));.)
		.
		
interface_signal_declaration_function<out InterfaceList.InterfaceSignalDeclaration signalElement> =
		(.Expression expr=null;boolean bus=false;.)
		[SIGNAL] identifier_list<out Seq<.Identifier.> list> COLON [IN] subtype_indication<out SubTypeIndication subType> [BUS(.bus=true;.)] [VAR_ASSIGN expression<out expr>]
		(.signalElement=new InterfaceList.InterfaceSignalDeclaration(list,toOption(InterfaceMode.IN()),subType,bus,toOption(expr));.)
		.
	
interface_variable_declaration<out InterfaceList.InterfaceVariableDeclaration varElement> =
		(.Expression expr=null;scala.Enumeration.Value mode=null;.)
		[VARIABLE] identifier_list<out Seq<.Identifier.> list> COLON [interface_mode<out mode>] subtype_indication<out SubTypeIndication subType> [VAR_ASSIGN expression<out expr>]
		(.varElement=new InterfaceList.InterfaceVariableDeclaration(list,toOption(mode),subType,toOption(expr));.)
		.
	
interface_mode<out scala.Enumeration.Value mode> =
		(.mode=null;.)
		(
		IN (.mode=InterfaceMode.IN();.)
		|OUT (.mode=InterfaceMode.OUT();.)
		|INOUT (.mode=InterfaceMode.INOUT();.)
		|BUFFER (.mode=InterfaceMode.BUFFER();.)
		|LINKAGE (.mode=InterfaceMode.LINKAGE();.)
		)
		.

interface_file_declaration<out InterfaceList.InterfaceFileDeclaration fileElement> =
		FILE identifier_list<out Seq<.Identifier.> list> COLON subtype_indication<out SubTypeIndication subType>
		(.fileElement=new InterfaceList.InterfaceFileDeclaration(list,subType);.)
		.

association_element<out AssociationList.Element element> =
		//TODO ((formal_part ARROW)=>formal_part ARROW)? actual_part
		(.element=new AssociationList.Element($formal_part.formal_part_,$actual_part.actual_part_);.)
		.	
		  
association_list<out AssociationList list> =
		(.
		  MyListBuffer<AssociationList.Element> elements=new MyListBuffer<AssociationList.Element>();
		  AssociationList.Element element=null;
		.)
		association_element<out element> (.elements.append(element);.) {COMMA association_element<out element> (.elements.append(element);.)}
		(.list=new AssociationList(elements.toList());.)
		.
	
formal_part<out Name formal_part> =
		name<out formal_part>
		.
		
actual_part<out Option<Expression> actual_part> = 
		expression<out Expression expr> (.actual_part = toOption(expr);.)
		| OPEN (.actual_part=scala.None$.MODULE$;.)
		.
			
condition<out Expression expr> =
		expression<out expr>
		.
	 
expression<out Expression expr> =
		(.Tuple2<Position,scala.Enumeration.Value> op=null;.)
	   relation<out expr> (
	   //TODO (nand=NAND|nor=NOR) r2=relation {$expr=new LogicalExpression(toPosition(if($nand ne null) $nand else $nor),$r1.rel,if ($nand ne null) LogicalExpression.Operator.NAND else LogicalExpression.Operator.NOR,$r2.rel)}
	   {logical_operator<out op> relation<out Expression right> (.expr=new LogicalExpression(op._1,expr,op._2,right);.)}
	   )
	   .

logical_operator<out Tuple2 op> =
		(.
		  Position pos=toPosition(la);
		  scala.Enumeration.Value logOp=null;
		.)
		(
		AND (.logOp=LogicalOperator.AND();.)
		|OR (.logOp=LogicalOperator.OR();.)
		|XOR (.logOp=LogicalOperator.XOR();.)
		|XNOR (.logOp=LogicalOperator.XNOR();.)
		//NAND and NOR are handled in expression
		)
		(.op=new Tuple2<Position,scala.Enumeration.Value>(pos,logOp);.)
		.

relation<out Expression rel> =
	(.Tuple2<Position,scala.Enumeration.Value> op=null;.)
    shift_expression<out rel>
    [relational_operator<out op> shift_expression<out Expression right> (.rel=new Relation(op._1,rel,op._2,right);.)]
    .

relational_operator<out Tuple2 op> =
		(.
			Position pos=toPosition(la);
			scala.Enumeration.Value relOp=null;
		.)
		(
	    EQ (.relOp=RelationOperator.EQ();.)
	  | NEQ (.relOp=RelationOperator.NEQ();.)
	  | LT (.relOp=RelationOperator.LT();.)
	  | LEQ (.relOp=RelationOperator.LEQ();.)
	  | GT (.relOp=RelationOperator.GT();.)
	  | GEQ (.relOp=RelationOperator.GEQ();.)
	  )
	  (.op=new Tuple2<Position,scala.Enumeration.Value>(pos,relOp);.)
	  .

	
shift_expression<out Expression shiftExpr> =
	(.Tuple2<Position,scala.Enumeration.Value> op=null;.)
    simple_expression<out shiftExpr>
    [shift_operator<out op> simple_expression<out Expression right> (.shiftExpr=new ShiftExpression(op._1,shiftExpr,op._2,right);.)]
    .

shift_operator<out Tuple2 op> =
(.  
    Position pos=toPosition(la);
    scala.Enumeration.Value shiftOp=null;
.)
		(
		SLL  (.shiftOp=ShiftOperator.SLL();.)
		|SRL (.shiftOp=ShiftOperator.SRL();.)
		|SLA (.shiftOp=ShiftOperator.SLA();.)
		|SRA (.shiftOp=ShiftOperator.SRA();.)
		|ROL (.shiftOp=ShiftOperator.ROL();.)
		|ROR (.shiftOp=ShiftOperator.ROR();.)
		)
		(.op=new Tuple2<Position,scala.Enumeration.Value>(pos,shiftOp);.)
		.
		
simple_expression<out Expression simpleExpr> =
	  (.Tuple2<Position,scala.Enumeration.Value> op=null,sign=null;.)
	  [sign<out sign>] term<out simpleExpr> 
	  (.if (sign!=null) simpleExpr=new SimpleExpression(sign._1,sign._2,simpleExpr,scala.None$.MODULE$,scala.None$.MODULE$);.)
	  {adding_operator<out op> term<out Expression right> (.simpleExpr=new SimpleExpression(op._1,scala.None$.MODULE$,simpleExpr,op._2,right);.)}
	  .

sign<out Tuple2<Position,scala.Enumeration.Value> op> =
(.  
    Position pos=toPosition(la);
    scala.Enumeration.Value signOp=null;
.)
		(
		PLUS (.signOp=SignOperator.PLUS();.)
		|MINUS (.signOp=SignOperator.MINUS();.)
		)
		(.op=new Tuple2<Position,scala.Enumeration.Value>(pos,signOp);.)
		.	
		
adding_operator<out Tuple2<Position,scala.Enumeration.Value> op> =
(.  
    Position pos=toPosition(la);
    scala.Enumeration.Value addOp=null;
.)
		(
		PLUS (.addOp=AddOperator.PLUS();.)
		|MINUS (.addOp=AddOperator.MINUS();.)
		|AMPERSAND (.addOp=AddOperator.AMPERSAND();.)
		)
		(.op=new Tuple2<Position,scala.Enumeration.Value>(pos,addOp);.)
		.

multiplying_operator<out Tuple2<Position,scala.Enumeration.Value> op>=
(.  
    Position pos=toPosition(la);
    scala.Enumeration.Value mulOp=null;
.)
		(
		MUL (.mulOp=TermOperator.MUL();.)
		|DIV (.mulOp=TermOperator.DIV();.)
		|MOD (.mulOp=TermOperator.MOD();.)
		|REM (.mulOp=TermOperator.REM();.)
		)
		(.op=new Tuple2<Position,scala.Enumeration.Value>(pos,mulOp);.)
		.

term<out Expression term> =
	   (.Tuple2<Position,scala.Enumeration.Value> op=null;.)
	   factor<out term>
	  [ multiplying_operator<out op> factor<out Expression right> (.term = new Term(op._1,term,op._2,right);.)]
	  .
 
factor<out Expression factor> =
	primary<out factor> [DOUBLESTAR (.Position pos=toPosition(t);.) primary<out Expression right> (.factor = new Factor(pos,factor,FactorOperator.POW(),right);.)]
	| ABS (.Position pos=toPosition(t);.) primary<out Expression left> (.factor = new Factor(pos,left,FactorOperator.ABS());.)
	| NOT (.Position pos=toPosition(t);.) primary<out Expression left> (.factor = new Factor(pos,left,FactorOperator.NOT());.)
	.

primary<out Expression expr> =
	(.expr=null;.)
	(
	 /* TODO
	 (selected_name qualified_expression[null]) =>selected_name qualified_expression[$selected_name.name_] {$obj=$qualified_expression.expr}
	 | (name)=>name {$obj=new NameExpression($name.name_)}
  	 | (selected_name LPAREN association_list RPAREN)=>function_call {$obj=$function_call.functionCall}
	 | literal {$obj=$literal.literal_} 
	 | (LPAREN expression RPAREN)=> LPAREN expression RPAREN {$obj=$expression.expr}
	 */
	 | allocator<out expr>
	 | aggregate<out Aggregate aggregate> (.expr=new AggregateExpression(aggregate);.)
	 )
	.

allocator<out Expression newExpression> =
	(.Position pos=toPosition(la);.)
	NEW selected_name<out SelectedName selectedName>  
	 	( qualified_expression<out Expression expr,selectedName> (.newExpression=new NewExpression(pos,new Left(expr));.)
	 	| [index_constraint<out Seq<.DiscreteRange.> ranges> (.newExpression=new NewExpression(pos,new Right(new SubTypeIndication(scala.None$.MODULE$,selectedName,new Right(ranges))));.)]
	 	)
	 	.

function_call<out FunctionCallExpression functionCall> =
		(.AssociationList parameter_association_list=null;.)
		selected_name<out SelectedName function_name> [LPAREN association_list<out parameter_association_list> RPAREN]
		(.functionCall=new FunctionCallExpression(function_name,toOption(parameter_association_list));.)
		.
	
qualified_expression<out QualifiedExpression expr,SelectedName typeName> =
		APOSTROPHE aggregate<out Aggregate aggregate>
		(.expr=new QualifiedExpression(typeName,new AggregateExpression(aggregate));.)
		.

selected_name_list<out Seq<SelectedName> list> =
(.
	MyListBuffer<SelectedName> tmpList=new MyListBuffer<SelectedName>();
	SelectedName name;
.)
		selected_name<out name> (.tmpList.append(name);.) {COMMA selected_name<out name> (.tmpList.append(name);.) }
		(.list=tmpList.toList();.)
		.
		
selected_name<out SelectedName name> =
		(. MyListBuffer<Identifier> parts=new MyListBuffer<Identifier>();.)
		name_prefix<out Identifier prefix> { name_selected_part<out Name.SelectedPart selectedPart> (.parts.append(selectedPart.identifier());.)}
		(.parts.prepend(prefix); name =new SelectedName(parts.toList());.)
		.

name_list<out Seq<Name> list> =
(.
	MyListBuffer<Name> tmpList=new MyListBuffer<Name>();
.)
		name<out Name name> (.tmpList.append(name);.) {COMMA name<out name> (.tmpList.append(name);.)}
		(.list=tmpList.toList();.)
		.
			
name<out Name name> =
		(.MyListBuffer<Name.Part> parts=new MyListBuffer<Name.Part>();.)
		name_prefix<out Identifier prefix> //TODO( (name_part)=> name_part {parts.append($name_part.part)})*
	  	(.name =new Name(prefix,parts.toList());.)
  		.

name_prefix<out Identifier identifier> =
	(.identifier=null;.)
	(
 	  identifier<out identifier>
 	| STRING_LITERAL (.identifier=toIdentifier(t);.)
 	)
 	.
 	
name_part<out Name.Part part> =
	 (.part=null;.)
	 (
  	 name_selected_part<out part>
   	 | name_attribute_part<out part>
   	 //TODO | (name_indexed_part)=>name_indexed_part<out part>
  	 | name_slice_part<out part>
  	 )
  	 .
		
name_selected_part<out Name.SelectedPart part> =
		(.part=null;.)
		DOT (
		identifier<out Identifier identifier>(.part= new Name.SelectedPart(identifier);.)
		|CHARACTER_LITERAL (.part= new Name.SelectedPart(toIdentifier(t));.)
		|STRING_LITERAL(.part= new Name.SelectedPart(toIdentifier(t));.)
		|ALL(.part= new Name.SelectedPart(toIdentifier(t));.)
		)
		.
		
name_slice_part<out Name.SlicePart part> =
		LPAREN discrete_range<out DiscreteRange discreteRange> RPAREN  (.part=new Name.SlicePart(discreteRange);.)
		.
				
name_indexed_part<out Name.IndexPart part> =
		(. MyListBuffer<Expression> indexes=new MyListBuffer<Expression>(); .)
		 LPAREN expression<out Expression expr> (.indexes.append(expr);.) {COMMA expression<out expr> (.indexes.append(expr);.)} RPAREN (.part=new Name.IndexPart(indexes.toList());.) 
		 .

name_attribute_part<out Name.AttributePart part> =
		[signature<out Signature signature>] APOSTROPHE //TODO(id=identifier|RANGE {id=toIdentifier($RANGE)})
	//TODO ( (LPAREN expression RPAREN)=> LPAREN expression<out expr> RPAREN)? {$part=new Name.AttributePart($signature.signature_,$id.id,$expression.expr)}
	.
		
signature<out Signature signature> =
		(.Seq<SelectedName> list=null;SelectedName returnType=null;.)
		LBRACKET [selected_name_list<out list>] [RETURN type_mark<out returnType>] RBRACKET
		(.signature =new Signature(toOption(list),toOption(returnType));.)
		.
/*	TODO
literal returns [Expression literal_]
@init{
	var literalType:Literal.Type.Value=null
	val firstToken=la
}
	:	
		(
		REAL_LITERAL {literalType=Literal.Type.REAL_LITERAL}
		| INTEGER_LITERAL {literalType=Literal.Type.INTEGER_LITERAL}
		| BASED_LITERAL {literalType=Literal.Type.BASED_LITERAL}
		| CHARACTER_LITERAL {literalType=Literal.Type.CHARACTER_LITERAL}
		| STRING_LITERAL {literalType=Literal.Type.STRING_LITERAL}
		| BIT_STRING_LITERAL {literalType=Literal.Type.BIT_STRING_LITERAL}
		| NULL {literalType=Literal.Type.NULL_LITERAL}
		)
		{$literal_ =new Literal(toPosition(firstToken),input.LT(-1).getText(),literalType)}
		({input.LA(-1)==INTEGER_LITERAL || input.LA(-1)==REAL_LITERAL /*|| input.LA(-1)==BASED_LITERAL*/}?=> identifier {$literal_ = new PhysicalLiteral($literal_.asInstanceOf[Literal],$identifier.id)})?
		;
	
physical_literal returns [PhysicalLiteral literal_]
@init{
	var text:String=null
	var literalType:Literal.Type.Value=null
	val firstToken=la
}
	:	(INTEGER_LITERAL {text=input.LT(-1).getText(); literalType=Literal.Type.INTEGER_LITERAL}
		|REAL_LITERAL {text=input.LT(-1).getText(); literalType=Literal.Type.REAL_LITERAL}
		//|BASED_LITERAL {str=input.LT(-1).getText(); literalType=Literal.Type.BASED_LITERAL} //TODO
		)
		unit_name=identifier
		{$literal_ =new PhysicalLiteral(toPosition(firstToken),text,$unit_name.id,literalType)}
		;
	
element_association returns [Aggregate.ElementAssociation element]
	  : ( (choices ARROW)=> choices ARROW )? expression 
	  	{$element=new Aggregate.ElementAssociation($choices.choices_,$expression.expr)}
	  	;
*/

choice<out Object x> = "öksdf".

element_association<out Object x> = "öksdsdf".

physical_literal<out Object x> = "öksdsdf".

aggregate<out Aggregate aggregate> =
		(. MyListBuffer<Aggregate.ElementAssociation> elements=new MyListBuffer<Aggregate.ElementAssociation>(); .)
		LPAREN  element_association<out Aggregate.ElementAssociation element>(.elements.append(element);.) {COMMA element_association<out element> (.elements.append(element);.)} RPAREN
		(.aggregate =new Aggregate(elements.toList());.)
		.

/*
choice	returns [Choices.Choice choice_]
@init{
	val firstToken=la
}
	:	
		(simple_expression direction)=> d=discrete_range {choice_ =new Choices.Choice(toPosition(firstToken),Some(new Left($d.discreteRange)))}
		| expr=simple_expression {choice_ =new Choices.Choice(toPosition(firstToken),Some(new Right($expr.simpleExpr)))}
		| OTHERS {choice_ =new Choices.Choice(toPosition(firstToken),scala.None$.MODULE$)}
		;
*/
choices<out Choices choices> =
		(. MyListBuffer<Choices.Choice> elements=new MyListBuffer<Choices.Choice>(); .)
		choice<out Choices.Choice choice> (.elements.append(choice);.) { BAR choice<out choice> (.elements.append(choice);.)}
		(.choices =new Choices(elements.toList());.)
		.
	
identifier_list<out Seq<Identifier> list> =
(.
	MyListBuffer<Identifier> tmpList=new MyListBuffer<Identifier>();
	Identifier identifier=null;
.)
		identifier<out identifier> (.tmpList.append(identifier);.) {COMMA identifier<out identifier> (.tmpList.append(identifier);.) } 
		(.list=tmpList.toList();.)
		.
		
unused_identifier = identifier<out Identifier unused>.
			
identifier<out Identifier id> =
		(.id=null;.)
		(
		BASIC_IDENTIFIER (. id=toIdentifier(t);.)
		| EXTENDED_IDENTIFIER (. id=toIdentifier(t,false);.)
		)
		.

label_colon<out Identifier label> =
		identifier<out label> COLON
		.
		
END VHDL.
